<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title id="title">Timing & Render Tool</title>

<style>
@import url('https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@400;500;600;700&display=swap');

body {
    color-scheme: dark; 
    background: radial-gradient(circle at 20% 20%, #0f1c2e, #050b18 70%);
    font-family: 'Google Sans', 'Be Vietnam Pro', 'Segoe UI', sans-serif;
    color: #e6f3ff;
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 0;
    padding: 40px 20px 80px 20px;
    min-height: 100vh;
    box-sizing: border-box;
    transition: background 0.5s ease;
}

/* --- AI THEME (GEMINI STYLE) --- */
body.ai-theme {
    background: radial-gradient(circle at 20% 20%, #14284a 0%, #0a1530 40%, #060b19 72%, #030610 100%);
    position: relative;
}
body.ai-theme::before {
    content: ""; position: fixed; inset: -25%; pointer-events: none; z-index: -1;
    background:
        radial-gradient(40% 35% at 25% 30%, rgba(66,133,244,0.42), transparent 70%),
        radial-gradient(34% 30% at 75% 35%, rgba(155,114,203,0.36), transparent 72%),
        radial-gradient(42% 40% at 50% 80%, rgba(68,196,255,0.24), transparent 75%);
    filter: blur(22px) saturate(1.25);
    animation: aiAmbientFlow 4.8s ease-in-out infinite alternate;
}
body.ai-theme .container {
    background: #04070f;
    border: 1px solid rgba(66, 133, 244, 0.25);
    box-shadow: 0 0 35px rgba(66, 133, 244, 0.12), inset 0 0 40px rgba(0, 0, 0, 0.6);
}
body.ai-theme .container::before {
    content: ""; position: absolute; inset: 0; border-radius: 20px; padding: 1.5px;
    background: linear-gradient(45deg, #4285f4, #9b72cb, #d96570, #4285f4);
    background-size: 300% 300%;
    animation: aiGradient 4s ease infinite;
    -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
    -webkit-mask-composite: xor;
    mask-composite: exclude;
    pointer-events: none;
}
@keyframes aiGradient {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}
@keyframes aiAmbientFlow {
    0% { transform: translate3d(-3%, -2%, 0) scale(1); opacity: .86; }
    50% { transform: translate3d(2%, 1%, 0) scale(1.07); opacity: 1; }
    100% { transform: translate3d(4%, -1%, 0) scale(1.12); opacity: .88; }
}

body.ai-theme.gemini-neon::before {
    background:
        radial-gradient(42% 36% at 22% 28%, rgba(0,255,255,0.5), transparent 68%),
        radial-gradient(38% 32% at 76% 34%, rgba(140,82,255,0.46), transparent 72%),
        radial-gradient(44% 44% at 52% 82%, rgba(0,184,255,0.32), transparent 76%);
    filter: blur(18px) saturate(1.45) brightness(1.15);
    animation-duration: 3.6s;
}
body.ai-theme.gemini-neon .container {
    border-color: rgba(0, 238, 255, 0.52);
    box-shadow: 0 0 42px rgba(0, 210, 255, 0.28), inset 0 0 45px rgba(0, 18, 38, 0.82);
}
body.ai-theme.gemini-neon .container::before {
    background: linear-gradient(45deg, #00f0ff, #8a6dff, #31d5ff, #00f0ff);
    animation-duration: 2.8s;
}
body.ai-theme h1 {
    background: linear-gradient(90deg, #4285f4, #9b72cb, #d96570, #4285f4);
    background-size: 200% auto;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    animation: textShine 3s linear infinite;
    text-shadow: none;
}
@keyframes textShine { to { background-position: 200% center; } }

.ai-btn {
    background: linear-gradient(90deg, #4285f4, #9b72cb, #d96570) !important;
    border: none !important; color: white !important; font-family: inherit;
    box-shadow: 0 0 15px rgba(155, 114, 203, 0.4) !important; transition: 0.3s;
}
.ai-btn:hover:not(:disabled) { filter: brightness(1.15); box-shadow: 0 0 25px rgba(155, 114, 203, 0.6) !important; transform: translateY(-1px); }
.ai-btn:disabled { opacity: 0.6; cursor: not-allowed; filter: grayscale(0.5); }
.ai-text-glow {
    background: linear-gradient(90deg, #4285f4, #9b72cb, #d96570, #4285f4); background-size: 200% auto;
    -webkit-background-clip: text; -webkit-text-fill-color: transparent; font-weight: 600; animation: textShine 3s linear infinite;
}
.ai-auth-box { margin-bottom: 20px; padding: 20px; background: rgba(0, 204, 255, 0.04); border: 1px dashed rgba(0, 204, 255, 0.3); border-radius: 12px; box-shadow: inset 0 0 15px rgba(0, 204, 255, 0.05); }
.ai-pill { display: flex; justify-content: space-between; align-items: center; padding: 12px 18px; background: rgba(66, 133, 244, 0.1); border: 1px solid rgba(66, 133, 244, 0.4); border-radius: 10px; margin-bottom: 20px; box-shadow: 0 4px 15px rgba(66, 133, 244, 0.1); }
.logic-inline { display: flex; gap: 10px; align-items: stretch; flex-wrap: wrap; }
.logic-inline .custom-select-wrapper { flex: 1 1 0; min-width: 0; }
.ai-provider-inline { width: 100%; }
.ai-log-panel { margin-top: 15px; border: 1px solid rgba(133, 181, 255, 0.7); background: rgba(3, 8, 20, 0.98); border-radius: 12px; padding: 12px; box-shadow: inset 0 0 28px rgba(58, 106, 196, 0.16); }
.ai-log-title { font-size: 13px; color: #dff0ff; margin-bottom: 10px; font-weight: 700; }
.ai-log-list { max-height: 340px; overflow: auto; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 12px; color: #f0f8ff; line-height: 1.52; }
.ai-log-item { margin-bottom: 10px; border-left: 2px solid rgba(155,114,203,.9); padding: 8px 8px 8px 10px; background: rgba(14, 23, 43, 0.95); border-radius: 8px; white-space: pre-wrap; word-break: break-word; }
.ai-log-meta { display: flex; align-items: center; justify-content: space-between; gap: 10px; margin-bottom: 4px; }
.ai-log-type { font-size: 11px; color: #9ac4ff; font-weight: 700; text-transform: uppercase; letter-spacing: .2px; }
.ai-log-time { font-size: 11px; color: #84a0c4; }
.ai-log-msg { font-size: 12px; color: #f2f8ff; }
.ai-log-msg details { margin-top: 4px; }
.ai-log-msg summary { cursor: pointer; color: #9bc4ff; font-weight: 600; }
.ai-log-msg pre { margin: 6px 0 0 0; padding: 8px; border-radius: 6px; background: rgba(5, 12, 25, 0.95); border: 1px solid rgba(126, 170, 244, 0.25); color: #eaf4ff; white-space: pre-wrap; word-break: break-word; font-family: inherit; }
.ai-log-item.log-request { border-left-color: #8ab4f8; }
.ai-log-item.log-response { border-left-color: #9b72cb; }
.ai-log-item.log-error { border-left-color: #ff8a80; }

.tool-gemini-burst { position: absolute; inset: 0; overflow: hidden; border-radius: inherit; pointer-events: none; z-index: 3; }
.tool-gemini-burst .gem-star {
    position: absolute; width: 9px; height: 9px; border-radius: 50%;
    background: radial-gradient(circle, #fff 0%, #8ab4f8 35%, #9b72cb 70%, transparent 72%);
    box-shadow: 0 0 14px rgba(138, 180, 248, 0.85);
    transform: translate(-50%, -50%) scale(0.2);
    opacity: 0;
    animation: gemSpread 1.95s cubic-bezier(.16,.82,.21,1) forwards;
}
.tool-gemini-burst .gem-ring {
    position: absolute; width: 12px; height: 12px; border-radius: 999px;
    border: 2px solid rgba(138, 180, 248, 0.95);
    transform: translate(-50%, -50%) scale(.1);
    opacity: 0;
    animation: gemRingExpand 1.8s ease-out forwards;
}
@keyframes gemSpread {
    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.08); }
    10% { opacity: 1; }
    100% { opacity: 0; transform: translate(calc(-50% + var(--dx)), calc(-50% + var(--dy))) scale(1.9); }
}
@keyframes gemRingExpand {
    0% { opacity: .86; transform: translate(-50%, -50%) scale(.08); }
    100% { opacity: 0; transform: translate(-50%, -50%) scale(22); }
}
/* -------------------------- */

h1 { margin: 0 0 10px 0; font-size: 28px; text-align: center; color: #00ccff; text-shadow: 0 0 20px rgba(0,200,255,0.6); transition: 0.5s; }
.intro { text-align: center; max-width: 600px; margin-bottom: 30px; opacity: 0.8; line-height: 1.5; font-size: 15px; }

.container {
    background: linear-gradient(145deg, #0e1624, #111c2f);
    z-index: 1;
    padding: 35px; border-radius: 20px; width: 100%; max-width: 600px; 
    box-shadow: 0 0 40px rgba(0,140,255,0.25), inset 0 0 60px rgba(0,80,160,0.15);
    border: 1px solid rgba(0,180,255,0.35); box-sizing: border-box; transition: 0.5s;
    outline: 1px solid rgba(149, 217, 255, 0.18);
    outline-offset: -1px;
    position: relative; isolation: isolate;
}

.tabs { display: flex; gap: 8px; margin-bottom: 25px; flex-wrap: wrap; }
.tabs button {
    flex: 1; min-width: 120px; padding: 12px 5px; min-height: 44px;
    background: #0c1626; border: 1px solid #1b3555; border-radius: 10px;
    color: #7fbfff; cursor: pointer; transition: 0.3s; font-weight: 500; font-family: inherit; font-size: 14px;
}
.tabs button:hover { background: #11233d; box-shadow: 0 0 12px rgba(0,170,255,0.4); }
.tabs button.active { background: linear-gradient(90deg,#0066ff,#00ccff); color: white; border-color: #00ccff; box-shadow: 0 0 20px rgba(0,200,255,0.6); }

.tab-desc { font-size: 13px; color: #9ed8ff; background: rgba(0, 150, 255, 0.08); border-left: 3px solid #00ccff; padding: 12px 15px; margin-bottom: 22px; border-radius: 0 8px 8px 0; line-height: 1.5; }
.row { margin-bottom: 20px; transition: all 0.3s ease; }
label { display: flex; align-items: center; margin-bottom: 8px; font-size: 14px; opacity: 0.85; color: #9ed8ff; }

input[type="number"], input[type="password"] {
    width: 100%; padding: 14px; font-size: 15px; min-height: 44px; font-family: inherit;
    background: #0a1422; border: 1px solid #1e3a5f; border-radius: 10px; color: #e6f3ff; transition: 0.3s; box-sizing: border-box;
}
input[type="number"]:focus, input[type="password"]:focus { outline: none; border-color: #00ccff; box-shadow: 0 0 12px rgba(0,200,255,0.5); }

/* CUSTOM DROPDOWN */
.custom-select-wrapper { position: relative; width: 100%; }
.custom-select-wrapper:has(select.hidden) { display: none !important; }
.input-group .custom-select-wrapper { flex: 1; }
.custom-select-trigger {
    width: 100%; padding: 14px; font-size: 14px; font-family: inherit; min-height: 44px;
    background: #0a1422; border: 1px solid #1e3a5f; border-radius: 10px; color: #e6f3ff; cursor: pointer; display: flex; justify-content: space-between; align-items: center; transition: 0.3s; box-sizing: border-box; user-select: none;
}
.custom-select-trigger:hover, .custom-select-trigger.active { border-color: #00ccff; box-shadow: 0 0 12px rgba(0,200,255,0.5); }
.custom-select-trigger .arrow { width: 16px; height: 16px; background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%239ed8ff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e"); background-size: contain; background-repeat: no-repeat; background-position: center; transition: transform 0.3s; }
.custom-select-trigger.active .arrow { transform: rotate(180deg); }
.custom-select-options {
    position: absolute; top: calc(100% + 5px); left: 0; right: 0; background: #0a1422;
    border: 1px solid #1e3a5f; border-radius: 10px; box-shadow: 0 5px 20px rgba(0,0,0,0.6); z-index: 99; opacity: 0; visibility: hidden; transform: translateY(-10px); transition: all 0.2s ease-out; overflow-y: auto; max-height: 250px;
}
.custom-select-options.show { opacity: 1; visibility: visible; transform: translateY(0); }
.custom-select-option { padding: 14px; font-size: 14px; cursor: pointer; transition: 0.2s; color: #e6f3ff; border-bottom: 1px solid rgba(30, 58, 95, 0.4); }
.custom-select-option:last-child { border-bottom: none; }
.custom-select-option:hover, .custom-select-option.selected { background: #11233d; color: #00ccff; }

.input-group { display: flex; gap: 10px; flex-wrap: wrap; }
.input-group input[type="number"], .input-group .custom-select-wrapper { flex: 1; min-width: 140px; }
.fps-presets { display: flex; gap: 8px; margin-top: 10px; }
.fps-presets button { flex: 1; padding: 10px 6px; background: #0e1c2f; border: 1px solid #1f4068; border-radius: 8px; color: #66ccff; cursor: pointer; font-size: 13px; transition: 0.2s; min-height: 40px; }
.fps-presets button:hover { background: #133a66; box-shadow: 0 0 8px rgba(0,200,255,0.6); }

.result { margin-top: 25px; font-size: 24px; font-weight: bold; color: #00ccff; text-align: center; text-shadow: 0 0 15px rgba(0,200,255,0.6); }
.sub-result { display: block; font-size: 14px; font-weight: normal; color: #9ed8ff; margin-top: 8px; opacity: 0.9; line-height: 1.5; }
.box-result { font-size: 14px; color: #cceeff; background: rgba(0, 102, 255, 0.1); border: 1px dashed #0066ff; padding: 15px; border-radius: 10px; margin-top: 15px; text-align: left; line-height: 1.6;}
.box-safe { border-color: #00ccff !important; background: rgba(0, 204, 255, 0.1) !important; color: #cceeff !important;}

.tooltip {
    display: inline-flex; align-items: center; justify-content: center; width: 18px; height: 18px; background: rgba(0, 204, 255, 0.1); border: 1px solid #00ccff; border-radius: 50%; color: #00ccff; font-size: 12px; font-weight: bold; cursor: help; position: relative; margin-left: 8px; transition: 0.3s; flex-shrink:0;
}
.tooltip:hover { background: #00ccff; color: #0a1422; box-shadow: 0 0 10px rgba(0, 204, 255, 0.6); }
.tooltip:hover::after {
    content: attr(data-tip); position: absolute; bottom: 150%; left: 50%; transform: translateX(-50%); background: #02111f; padding: 12px 14px; font-size: 13px; font-weight: normal; border-radius: 8px; width: 250px; color: #cceeff; box-shadow: 0 4px 15px rgba(0,170,255,0.6); border: 1px solid rgba(0, 204, 255, 0.4); z-index: 9999; text-align: left; white-space: pre-wrap; line-height: 1.5; word-wrap: break-word;
}
.warning { margin-top: 15px; font-size: 14px; color: #ffcc66; background: rgba(255, 204, 102, 0.1); padding: 15px; border-radius: 10px; border: 1px solid rgba(255, 204, 102, 0.3); line-height: 1.5;}
.hidden { display: none !important; }

/* Graph Styling */
.graph-title-block { display: flex; justify-content: space-between; align-items: center; margin-top: 25px; margin-bottom: 8px; }
.graph-title { font-size: 13px; font-weight: 600; color: #9ed8ff; display: flex; align-items: center; justify-content: center; gap: 6px; }
.static-graph-wrapper { background: rgba(10, 20, 34, 0.4); border-radius: 12px; border: 1px dashed #1e3a5f; width: 100%; margin-top: 5px; box-sizing: border-box; display: flex; justify-content: center; padding: 15px 0; overflow: hidden; }
.graph-wrapper { margin-top: 5px; background: rgba(10, 20, 34, 0.6); border-radius: 12px; border: 1px solid #1e3a5f; width: 100%; overflow-x: auto; box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.5); padding: 15px 0 0 0; -webkit-overflow-scrolling: touch; }
.graph-wrapper::-webkit-scrollbar { height: 8px; }
.graph-wrapper::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); border-radius: 10px; }
.graph-wrapper::-webkit-scrollbar-thumb { background: #1e3a5f; border-radius: 10px; }
.graph-wrapper::-webkit-scrollbar-thumb:hover { background: #00ccff; }
.graph-canvas { display: block; background: transparent; border: none; box-shadow: none; margin: 0 auto; }

/* Custom Curve Editor */
.custom-editor { margin-top: 12px; background: rgba(10, 20, 34, 0.6); border-radius: 12px; border: 1px solid #1e3a5f; overflow: hidden; box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.5); }
.custom-editor.disabled { opacity: 0.4; pointer-events: none; }
.custom-editor.hidden { display: none !important; }
.custom-editor-header { display: flex; justify-content: space-between; align-items: center; padding: 10px 15px; border-bottom: 1px solid #1e3a5f; background: rgba(0, 102, 255, 0.05); flex-wrap: wrap; gap: 8px; }
.custom-editor-title { font-size: 13px; font-weight: 600; color: #9ed8ff; display: flex; align-items: center; gap: 10px; }
.custom-editor-controls { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
.custom-preview-box { margin-top: 10px; padding: 0 15px 15px 15px; }

/* Checkbox Alignment */
.checkbox-lbl { font-size: 13px; color: #e6f3ff; display: flex; align-items: center; gap: 8px; cursor: pointer; user-select: none; margin: 0;}
.checkbox-lbl input[type="checkbox"] { appearance: none; -webkit-appearance: none; width: 16px; height: 16px; background: #0a1422; border: 1px solid #1e3a5f; border-radius: 4px; cursor: pointer; position: relative; margin: 0; outline: none; flex-shrink: 0; transition: 0.2s; }
.checkbox-lbl input[type="checkbox"]:checked { background: #00ccff; border-color: #00ccff; }
.checkbox-lbl input[type="checkbox"]:checked::after { content: ''; position: absolute; top: 2px; left: 5px; width: 4px; height: 8px; border: solid #050b18; border-width: 0 2px 2px 0; transform: rotate(45deg); }

.editor-btn { background: #0c1626; border: 1px solid #1b3555; color: #9ed8ff; border-radius: 6px; padding: 5px 10px; cursor: pointer; font-size: 11px; transition: 0.2s; white-space: nowrap;}
.editor-btn:hover { background: #11233d; color: #00ccff; border-color:#00ccff; }
.btn-reset { color: #ffcc66; border-color: rgba(255, 204, 102, 0.4); }
.btn-reset:hover { background: rgba(255, 204, 102, 0.1); border-color: #ffcc66; color: #ffcc66; }

.custom-editor-canvas-wrap { width: 100%; overflow-x: auto; -webkit-overflow-scrolling: touch; padding: 10px 0 0 0; }
.custom-editor-canvas-wrap::-webkit-scrollbar { height: 8px; }
.custom-editor-canvas-wrap::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); border-radius: 10px; }
.custom-editor-canvas-wrap::-webkit-scrollbar-thumb { background: #1e3a5f; border-radius: 10px; }
.custom-editor-canvas-wrap::-webkit-scrollbar-thumb:hover { background: #00ccff; }
.editor-canvas-inner { cursor: crosshair; touch-action: none; display: block; background: transparent; margin: 0 auto; }

.graph-legend-box { display: flex; justify-content: center; gap: 20px; padding: 12px 0 0 0; font-size: 13px; color: #9ed8ff; }
.graph-legend-box span { display: flex; align-items: center; gap: 6px; }

footer { margin-top: 40px; font-size: 14px; color: #66ccff; opacity: 0.8; display: flex; align-items: center; justify-content: center; gap: 10px; }
footer .custom-select-wrapper { width: auto; min-width: 110px; }
footer .custom-select-trigger { padding: 8px 12px; font-size: 14px; border-radius: 6px; min-height: unset; }
.note-text { font-size: 13px; color: #66ccff; margin-top: 6px; display: block; opacity: 0.8; }

@media (max-width: 600px) {
    body { padding: 20px 10px 50px 10px; }
    .container { padding: 25px 20px; border-radius: 15px; }
    h1 { font-size: 24px; }
    .ai-log-panel { display: block; margin-top: 12px; padding: 10px; }
    .ai-log-list { max-height: 220px; }
}
</style>
</head>

<body>

<div id="globalAiAuth" class="hidden ai-auth-box">
    <div class="row">
        <label><span id="lblAiKey">API Key</span></label>
        <input type="password" id="aiApiKey" data-i18n-ph="phAiKey" placeholder="Nh·∫≠p m√£ API Key c·ªßa b·∫°n...">
    </div>
    <button class="tabs button active ai-btn" onclick="connectAi()" style="width:100%; padding:14px; border-radius:10px; font-size:15px; font-weight:bold; cursor:pointer;" id="btnConnectAi">K·∫øt n·ªëi Tr·ª£ Th·ªß AI</button>
</div>

<div id="globalAiPill" class="hidden ai-pill">
    <span style="font-size:13px; color:#9ed8ff;"><span id="txtAiConnected">‚ú® ƒê√£ k·∫øt n·ªëi v·ªõi</span> <b id="aiProviderName" class="ai-text-glow">Gemini</b></span>
    <span style="font-size:12px; color:#ff6b6b; cursor:pointer; font-weight:bold; padding:4px 8px; background:rgba(255,107,107,0.1); border-radius:6px;" onclick="disconnectAi()" id="btnDisconnectAi">Ng·∫Øt k·∫øt n·ªëi</span>
</div>
<h1 id="mainTitle">Timing & Render Tool</h1>
<div class="intro" id="introText">C√¥ng c·ª• ƒëa nƒÉng h·ªó tr·ª£ Animation Timing, T√≠nh to√°n Frame v√† Render.</div>

<div class="container">
    <div id="toolGeminiBurst" class="tool-gemini-burst"></div>
    <div class="tabs">
        <button id="tabConvert" class="active" onclick="switchTab('convert')">Time / Frame</button>
        <button id="tabAnime" onclick="switchTab('anime')">Anime, Toon Frame</button>
        <button id="tabPose" onclick="switchTab('pose')">D·ª± t√≠nh Pose</button>
        <button id="tabRender" onclick="switchTab('render')">Render Time</button>
    </div>

    <div id="convertMode">
        <div class="tab-desc" id="descConvert">Chuy·ªÉn ƒë·ªïi qua l·∫°i gi·ªØa th·ªùi l∆∞·ª£ng (Gi√¢y/Ph√∫t/Gi·ªù) v√† S·ªë khung h√¨nh (Frames) theo t·ªëc ƒë·ªô chu·∫©n.</div>
        <div class="row">
            <label><span id="lblMode">Lo·∫°i t√≠nh</span><span class="tooltip" id="tipMode" data-tip="?">?</span></label>
            <select id="mode" onchange="updateConvert()"><option id="optF2T" value="f2t">Frame ‚Üí Time</option><option id="optT2F" value="t2f">Time ‚Üí Frame</option></select>
        </div>
        <div class="row">
            <label><span id="lblFPS_conv">FPS</span><span class="tooltip" id="tipFPS_conv" data-tip="?">?</span></label>
            <input type="number" id="fps" step="0.001" value="24" min="1" oninput="updateConvert()">
            <div class="fps-presets">
                <button onclick="setField('fps', 12); updateConvert()">12</button>
                <button onclick="setField('fps', 24); updateConvert()">24</button>
                <button onclick="setField('fps', 30); updateConvert()">30</button>
                <button onclick="setField('fps', 60); updateConvert()">60</button>
            </div>
        </div>
        <div class="row">
            <label><span id="lblInput">S·ªë khung h√¨nh/th·ªùi gian</span><span class="tooltip" id="tipInput" data-tip="?">?</span></label>
            <div class="input-group">
                <input type="number" id="inputValue" min="0" oninput="updateConvert()">
                <select id="timeUnit" class="hidden" onchange="updateConvert()"><option id="optSec" value="1">Gi√¢y</option><option id="optMin" value="60">Ph√∫t</option><option id="optHour" value="3600">Gi·ªù</option></select>
            </div>
        </div>
        <div class="result" id="convertOutput">‚Äî</div>
    </div>

    <div id="animeMode" class="hidden">
        <div class="tab-desc" id="descAnime">Ph√¢n b·ªï kho·∫£ng c√°ch c√°c Keyframe theo quy t·∫Øc Animation (On 1s, 2s, 3s) v√† n·ªôi suy nh·ªãp ƒë·ªô c·∫£nh.</div>
        
        <div class="row" id="rowLogicA">
            <label><span id="lblCalcLogic">Logic t√≠nh to√°n</span><span class="tooltip" id="tipCalcLogic" data-tip="?">?</span></label>
            <div class="logic-inline">
                <select id="calcLogic" onchange="toggleAnimePoseInput(); updateAnime()">
                    <option id="optLogicStrict" value="strict">To√°n h·ªçc nghi√™m ng·∫∑t</option>
                    <option id="optLogicRandom" value="random">X√°c su·∫•t ng·∫´u nhi√™n</option>
                    <option id="optLogicAI_A" value="ai">‚ú® Tr·ª£ Th·ªß AI</option>
                </select>
                <select id="aiProviderAnime" class="hidden ai-provider-inline" onchange="syncAiProviderFrom('anime')">
                    <option value="gemini">Google Gemini (Khuy√™n d√πng)</option>
                    <option value="chatgpt">OpenAI ChatGPT</option>
                </select>
            </div>
        </div>

        <div id="animeParams">
            <div class="row">
                <label><span id="lblFocus">T√¢m ƒëi·ªÉm & Tr·∫°ng th√°i</span><span class="tooltip" id="tipFocus" data-tip="?">?</span></label>
                <div class="input-group">
                    <select id="focusTarget" onchange="updateAnime()"><option id="optFocScene" value="scene">C·∫£nh</option><option id="optFocChar" value="char">Nh√¢n v·∫≠t/V·∫≠t th·ªÉ</option></select>
                    <select id="focusState" onchange="toggleAnimePoseInput(); updateAnime()"><option id="optStateStatic" value="static">Tƒ©nh</option><option id="optStateDynamic" value="dynamic" selected>ƒê·ªông</option></select>
                </div>
            </div>

            <div class="row">
                <label><span id="lblAnimStyle">Ki·ªÉu di·ªÖn ho·∫°t</span><span class="tooltip" id="tipAnimStyle" data-tip="?">?</span></label>
                <select id="animStyle" onchange="toggleAnimePoseInput(); updateAnime()"><option id="optOn1s" value="1">On 1s (M∆∞·ª£t / H√†nh ƒë·ªông)</option><option id="optOn2s" value="2" selected>On 2s (Chu·∫©n Anime)</option><option id="optOn3s" value="3">On 3s (Tƒ©nh / Ch·∫≠m)</option></select>
            </div>
            
            <div class="row">
                <label><span id="lblFPS_anime">FPS g·ªëc</span><span class="tooltip" id="tipFPS_anime" data-tip="?">?</span></label>
                <input type="number" id="fpsAnime" value="24" min="1" oninput="updateAnime()">
                <div class="fps-presets">
                    <button onclick="setField('fpsAnime', 12); updateAnime()">12</button>
                    <button onclick="setField('fpsAnime', 24); updateAnime()">24</button>
                    <button onclick="setField('fpsAnime', 30); updateAnime()">30</button>
                    <button onclick="setField('fpsAnime', 60); updateAnime()">60</button>
                </div>
            </div>

            <div class="row" id="rowCorePacingA">
                <label><span id="lblCorePacingAnime">Nh·ªãp t√¢m ƒëi·ªÉm</span><span class="tooltip" id="tipCorePacingAnime" data-tip="?">?</span></label>
                <select id="corePacingAnime" onchange="updateAnime()">
                    <option id="optCpSuperSlowA" value="superslow">Super Slow</option><option id="optCpSlowmoA" value="slowmo">Slow Motion</option><option id="optCpSlowA" value="slow">Ch·∫≠m</option><option id="optCpNormalA" value="normal" selected>B√¨nh th∆∞·ªùng</option><option id="optCpFastA" value="fast">Nhanh</option><option id="optCpSuperFastA" value="superfast">C·ª±c nhanh</option><option id="optCpTimeSplashA" value="timesplash">Time Splash</option>
                </select>
            </div>

            <div class="row" id="rowCurveTypeA">
                <label><span id="lblCurveTypeAnime">Lo·∫°i ƒë·ªì th·ªã (Ph√¢n b·ªï)</span><span class="tooltip" id="tipCurveTypeAnime" data-tip="?">?</span></label>
                <select id="curveTypeAnime" onchange="toggleAnimeCustom(); updateAnime()">
                    <option id="optCvNoneA" value="linear">Kh√¥ng (ƒê·ªÅu)</option><option id="optCvEaseOutA" value="ease_out">ƒê·ªì th·ªã xu·ªëng (Ch·∫≠m d·∫ßn)</option><option id="optCvEaseInA" value="ease_in">ƒê·ªì th·ªã l√™n (Nhanh d·∫ßn)</option><option id="optCvClimaxA" value="climax">ƒêi·ªÉm cao tr√†o (Nhanh gi·ªØa)</option><option id="optCvLowPointA" value="low_point">ƒêi·ªÉm tr·∫ßm (Ch·∫≠m gi·ªØa)</option><option id="optCvWaveA" value="wave">S√≥ng (Nhanh ch·∫≠m xen k·∫Ω)</option><option id="optCvCustomA" value="custom">T√πy ch·ªânh (ƒê·ªì th·ªã t·ªëc ƒë·ªô)</option>
                </select>
                
                <div id="customEditorWrap_anime" class="custom-editor hidden">
                    <div class="custom-editor-header">
                        <div class="custom-editor-title">
                            <span id="lblEditorA">Time Remapping</span>
                            <label class="checkbox-lbl"><input type="checkbox" id="smoothCurve_anime" checked> <span id="lblSmoothA">M∆∞·ª£t</span></label>
                            <label class="checkbox-lbl"><input type="checkbox" id="lockEnd_anime" checked> <span id="lblLockA">Kh√≥a m√∫t</span></label>
                        </div>
                        <div class="custom-editor-controls">
                            <button class="editor-btn btn-reset" onclick="resetCustomPoints('anime')" id="btnResetA">ƒê·∫∑t l·∫°i</button>
                            <button class="editor-btn" onclick="modifyCustomPoints('anime', 1)">+ ƒêi·ªÉm</button>
                            <button class="editor-btn" onclick="modifyCustomPoints('anime', -1)">‚àí ƒêi·ªÉm</button>
                        </div>
                    </div>
                    <div class="custom-editor-canvas-wrap">
                        <canvas id="customCanvas_anime" class="editor-canvas-inner"></canvas>
                    </div>
                    <div class="custom-preview-box">
                        <div class="graph-title" style="margin-top:10px;margin-bottom:8px;"><span data-i18n="lblCustomPreview">B·∫£n sao: T·ªïng quan (Gia t·ªëc)</span></div>
                        <div class="static-graph-wrapper" style="border:1px dashed rgba(0,204,255,0.3); background: rgba(0,0,0,0.25);"><canvas id="previewStatic_anime" class="graph-canvas"></canvas></div>
                    </div>
                </div>
                <div id="warnCustomAnime" class="warning hidden" style="color:#ffcc66; border-color:#ffcc66;"></div>
            </div>

            <div class="row" id="rowForceA">
                <label><span id="lblForceClampA">√âp Key cu·ªëi</span><span class="tooltip" id="tipForceClampA" data-tip="?">?</span></label>
                <select id="forceClampA" onchange="updateAnime()"><option id="optFCN_A" value="no">Kh√¥ng</option><option id="optFCY_A" value="yes">C√≥</option></select>
            </div>
            
            <div class="row" id="poseRow">
                <label><span id="lblPose">S·ªë Pose (Keyframes ch√≠nh)</span><span class="tooltip" id="tipPose" data-tip="?">?</span></label>
                <input type="number" id="poseCount" value="5" min="1" oninput="updateAnime()">
            </div>

            <div class="row">
                <label><span id="lblFrameRange">Frame B·∫Øt ƒë·∫ßu - K·∫øt th√∫c</span><span class="tooltip" id="tipFrameRange" data-tip="?">?</span></label>
                <div class="input-group">
                    <input type="number" id="startFrame" data-i18n-ph="phStartFrame" placeholder="B·∫Øt ƒë·∫ßu (vd: 1)" oninput="updateAnime(); toggleAnimeCustom()">
                    <input type="number" id="endFrame" data-i18n-ph="phEndFrame" placeholder="K·∫øt th√∫c (vd: 100)" oninput="updateAnime(); toggleAnimeCustom()">
                </div>
            </div>

            <button id="btnGenerateAiA" class="hidden ai-btn" onclick="generateWithAi('anime')" style="width:100%; padding:14px; margin-top:5px; border-radius:10px; font-size:15px; font-weight:bold; cursor:pointer;"><span id="txtBtnGenA">‚ú® T·ª± ƒë·ªông t·∫°o b·∫±ng AI</span></button>
        </div>
        
        <div class="result" id="animeOutput">‚Äî</div>
        <div class="warning" id="warnMathModelAnime">‚ö† L∆∞u √Ω: M√¥ h√¨nh ƒë·ªì th·ªã v√† to√°n h·ªçc ch·ªâ mang t√≠nh ch·∫•t g·ª£i √Ω tham kh·∫£o.</div>
    </div>

    <div id="poseMode" class="hidden">
        <div class="tab-desc" id="descPose">T·ª± ƒë·ªông ∆∞·ªõc t√≠nh s·ªë l∆∞·ª£ng Pose ch√≠nh v√† Pose ph·ª• tr·ª£ (In-betweens) ph·ª• thu·ªôc v√†o h√†nh ƒë·ªông c·ª• th·ªÉ v√† th·ªùi l∆∞·ª£ng.</div>
        
        <div class="row" id="rowLogicP">
            <label><span id="lblPoseCalcMode">Logic t√≠nh to√°n</span><span class="tooltip" id="tipPoseCalcMode" data-tip="?">?</span></label>
            <div class="logic-inline">
                <select id="poseCalcMode" onchange="togglePoseSettings(); togglePoseCustom(); updatePoseEst()">
                    <option id="optPcalcSeconds" value="seconds" selected>Theo s·ªë gi√¢y c·∫£nh (To√°n h·ªçc)</option>
                    <option id="optPcalcRandom" value="random">X√°c su·∫•t ng·∫´u nhi√™n</option>
                    <option id="optLogicAI_P" value="ai">‚ú® Tr·ª£ Th·ªß AI</option>
                </select>
                <select id="aiProviderPose" class="hidden ai-provider-inline" onchange="syncAiProviderFrom('pose')">
                    <option value="gemini">Google Gemini (Khuy√™n d√πng)</option>
                    <option value="chatgpt">OpenAI ChatGPT</option>
                </select>
            </div>
        </div>

        <div id="poseParams">
            <div class="row" id="rowPoseSeconds">
                <label><span id="lblPoseSeconds">Nh·∫≠p s·ªë gi√¢y c·∫£nh</span><span class="tooltip" id="tipPoseSeconds" data-tip="?">?</span></label>
                <input type="number" id="poseSeconds" value="4" min="0.1" step="0.1" oninput="togglePoseCustom(); updatePoseEst()">
            </div>
            <div class="row">
                <label><span id="lblFPS_pose">FPS g·ªëc</span><span class="tooltip" id="tipFPS_pose" data-tip="?">?</span></label>
                <input type="number" id="fpsPose" value="24" min="1" oninput="updatePoseEst(); updateJerkHint()">
                <div class="fps-presets">
                    <button onclick="setField('fpsPose', 12); updatePoseEst(); updateJerkHint()">12</button>
                    <button onclick="setField('fpsPose', 24); updatePoseEst(); updateJerkHint()">24</button>
                    <button onclick="setField('fpsPose', 30); updatePoseEst(); updateJerkHint()">30</button>
                    <button onclick="setField('fpsPose', 60); updatePoseEst(); updateJerkHint()">60</button>
                </div>
            </div>
            <div class="row">
                <label><span id="lblAnimStylePose">Lo·∫°i di·ªÖn ho·∫°t</span><span class="tooltip" id="tipAnimStylePose" data-tip="?">?</span></label>
                <select id="animStylePose" onchange="togglePoseSettings(); updatePoseEst(); updateJerkHint()"><option id="optPO1" value="1">On 1s</option><option id="optPO2" value="2" selected>On 2s</option><option id="optPO3" value="3">On 3s</option></select>
            </div>
            <div class="row">
                <label><span id="lblFocusTypePose">Lo·∫°i t√¢m ƒëi·ªÉm</span><span class="tooltip" id="tipFocusTypePose" data-tip="?">?</span></label>
                <select id="focusTypePose" onchange="togglePoseActions(); updatePoseEst()"><option id="optFocCharP" value="char">Nh√¢n v·∫≠t</option><option id="optFocObjP" value="obj">V·∫≠t th·ªÉ</option></select>
            </div>
            <div class="row">
                <label><span id="lblFocusActionPose">H√†nh ƒë·ªông c·ª• th·ªÉ</span><span class="tooltip" id="tipFocusActionPose" data-tip="?">?</span></label>
                <select id="focusActionChar" class="" onchange="updatePoseEst()"><option value="talk" id="actTalk">N√≥i chuy·ªán</option><option value="walk" id="actWalk">ƒêi b·ªô</option><option value="run" id="actRun">Ch·∫°y</option><option value="fight" id="actFight">ƒê√°nh nhau</option><option value="other" id="actOtherC">H√†nh ƒë·ªông kh√°c</option></select>
                <select id="focusActionObj" class="hidden" onchange="updatePoseEst()"><option value="fly" id="actFly">Bay</option><option value="fall" id="actFall">R∆°i</option><option value="break" id="actBreak">V·ª°/G√£y</option><option value="bounce" id="actBounce">N·∫£y l√™n/xu·ªëng</option><option value="scale" id="actScale">Ph√≥ng to/Thu nh·ªè</option><option value="other" id="actOtherO">H√†nh ƒë·ªông kh√°c</option></select>
            </div>
            <div class="row">
                <label><span id="lblCorePacingPose">Nh·ªãp t√¢m ƒëi·ªÉm</span><span class="tooltip" id="tipCorePacingPose" data-tip="?">?</span></label>
                <select id="corePacingPose" onchange="updatePoseEst()"><option id="optCpSuperSlowP" value="superslow">Super Slow</option><option id="optCpSlowmoP" value="slowmo">Slow Motion</option><option id="optCpSlowP" value="slow">Ch·∫≠m</option><option id="optCpNormalP" value="normal" selected>B√¨nh th∆∞·ªùng</option><option id="optCpFastP" value="fast">Nhanh</option><option id="optCpSuperFastP" value="superfast">C·ª±c nhanh</option><option id="optCpTimeSplashP" value="timesplash">Time Splash</option></select>
            </div>
            <div class="row">
                <label><span id="lblCurveTypePose">Lo·∫°i ƒë·ªì th·ªã</span><span class="tooltip" id="tipCurveTypePose" data-tip="?">?</span></label>
                <select id="curveTypePose" onchange="togglePoseCustom(); updatePoseEst()">
                    <option id="optCvNoneP" value="linear">Kh√¥ng</option><option id="optCvEaseOutP" value="ease_out">ƒê·ªì th·ªã xu·ªëng</option><option id="optCvEaseInP" value="ease_in">ƒê·ªì th·ªã l√™n</option><option id="optCvClimaxP" value="climax">ƒêi·ªÉm cao tr√†o</option><option id="optCvLowPointP" value="low_point">ƒêi·ªÉm tr·∫ßm</option><option id="optCvWaveP" value="wave">S√≥ng (Cao/th·∫•p c·∫°nh nhau)</option><option id="optCvCustomP" value="custom">T√πy ch·ªânh (ƒê·ªì th·ªã t·ªëc ƒë·ªô)</option>
                </select>
                
                <div id="customEditorWrap_pose" class="custom-editor hidden">
                    <div class="custom-editor-header">
                        <div class="custom-editor-title">
                            <span id="lblEditorP">Time Remapping</span>
                            <label class="checkbox-lbl"><input type="checkbox" id="smoothCurve_pose" checked> <span id="lblSmoothP">M∆∞·ª£t</span></label>
                            <label class="checkbox-lbl"><input type="checkbox" id="lockEnd_pose" checked> <span id="lblLockP">Kh√≥a m√∫t</span></label>
                        </div>
                        <div class="custom-editor-controls">
                            <button class="editor-btn btn-reset" onclick="resetCustomPoints('pose')" id="btnResetP">ƒê·∫∑t l·∫°i</button>
                            <button class="editor-btn" onclick="modifyCustomPoints('pose', 1)">+ ƒêi·ªÉm</button>
                            <button class="editor-btn" onclick="modifyCustomPoints('pose', -1)">‚àí ƒêi·ªÉm</button>
                        </div>
                    </div>
                    <div class="custom-editor-canvas-wrap">
                        <canvas id="customCanvas_pose" class="editor-canvas-inner"></canvas>
                    </div>
                    <div class="custom-preview-box">
                        <div class="graph-title" style="margin-top:10px;margin-bottom:8px;"><span data-i18n="lblCustomPreview">B·∫£n sao: T·ªïng quan (Gia t·ªëc)</span></div>
                        <div class="static-graph-wrapper" style="border:1px dashed rgba(0,204,255,0.3); background: rgba(0,0,0,0.25);"><canvas id="previewStatic_pose" class="graph-canvas"></canvas></div>
                    </div>
                </div>
                <div id="warnCustomPose" class="warning hidden" style="color:#ff6b6b; border-color:#ff6b6b;"></div>
            </div>
            
            <div class="row" id="rowForceP">
                <label><span id="lblForceClampP">√âp Key cu·ªëi</span><span class="tooltip" id="tipForceClampP" data-tip="?">?</span></label>
                <select id="forceClampP" onchange="updatePoseEst()"><option id="optFCN_P" value="no">Kh√¥ng</option><option id="optFCY_P" value="yes">C√≥</option></select>
            </div>

            <div class="row">
                <label><span id="lblSubPose">Th√™m Pose ph·ª• tr·ª£ (In-betweens)</span><span class="tooltip" id="tipSubPose" data-tip="?">?</span></label>
                <select id="subPoseToggle" onchange="togglePoseSettings(); updatePoseEst()"><option id="optNo" value="no">Kh√¥ng</option><option id="optYes" value="yes">C√≥</option></select>
            </div>
            <div class="row hidden" id="rowSubPoseLogic">
                <label><span id="lblSubPoseLogic">Quy t·∫Øc Pose ph·ª• tr·ª£</span><span class="tooltip" id="tipSubPoseLogic" data-tip="?">?</span></label>
                <select id="subPoseLogic" onchange="updatePoseEst()"><option id="optSpRandom" value="random">X√°c su·∫•t ng·∫´u nhi√™n</option><option value="1">1 Pose ph·ª•</option><option value="2">2 Pose ph·ª•</option><option value="3">3 Pose ph·ª•</option><option value="4">4 Pose ph·ª•</option></select>
            </div>
            
            <div class="row" id="rowJerkiness">
                <label><span id="lblJerkiness">ƒê·ªô gi·∫≠t - kh·ª±ng (Stutter/Hold)</span><span class="tooltip" id="tipJerkiness" data-tip="?">?</span></label>
                <select id="jerkToggle" onchange="togglePoseSettings(); updatePoseEst()"><option id="optJerkNo" value="no">Kh√¥ng</option><option id="optJerkSec" value="sec">Theo Gi√¢y</option><option id="optJerkFrame" value="frame">Theo Frame</option></select>
                <div id="jerkInputBlock" class="hidden" style="margin-top: 10px;">
                    <input type="number" id="jerkValue" value="2" min="0" step="0.1" oninput="updatePoseEst()">
                    <span id="jerkHint" class="note-text hidden"></span>
                </div>
            </div>

            <button id="btnGenerateAiP" class="hidden ai-btn" onclick="generateWithAi('pose')" style="width:100%; padding:14px; margin-top:5px; border-radius:10px; font-size:15px; font-weight:bold; cursor:pointer;"><span id="txtBtnGenP">‚ú® T·ª± ƒë·ªông t·∫°o b·∫±ng AI</span></button>
        </div>
        
        <div class="result" id="poseOutput">‚Äî</div>
        <div class="warning" id="warnMathModelPose">‚ö† L∆∞u √Ω: H·ªá th·ªëng ch·ªâ t√≠nh to√°n g·ª£i √Ω v·ªã tr√≠ l√Ω thuy·∫øt, m·∫≠t ƒë·ªô th·ª±c t·∫ø ph·ª• thu·ªôc b·∫£n v·∫Ω.</div>
    </div>

    <div id="aiLogPanel" class="ai-log-panel hidden">
        <div class="ai-log-title">AI Request / Response Log</div>
        <div id="aiLogList" class="ai-log-list"></div>
    </div>

    <div id="renderMode" class="hidden">
        <div class="tab-desc" id="descRender">∆Ø·ªõc t√≠nh t·ªïng th·ªùi gian xu·∫•t file (Render) c·ªßa to√†n b·ªô d·ª± √°n d·ª±a tr√™n th·ªùi gian ch·∫°y 1 khung h√¨nh.</div>
        <div class="row">
            <label><span id="lblTotalFrames">T·ªïng s·ªë frame</span><span class="tooltip" id="tipTotalFrames" data-tip="?">?</span></label>
            <input type="number" id="totalFrames" min="0" oninput="updateRender()">
        </div>
        <div class="row">
            <label><span id="lblRenderPerFrame">Th·ªùi gian render 1 frame (gi√¢y)</span><span class="tooltip" id="tipRenderPerFrame" data-tip="?">?</span></label>
            <input type="number" id="renderPerFrame" step="0.01" min="0" oninput="updateRender()">
        </div>
        <div class="result" id="renderOutput">‚Äî</div>
        <div class="warning" id="warningTextRender">‚ö† Ch·ªâ d√πng ƒë·ªÉ tham kh·∫£o. M·∫≠t ƒë·ªô chi ti·∫øt c·∫£nh th·ª±c t·∫ø s·∫Ω l√†m ƒë·ªïi th·ªùi gian.</div>
    </div>
</div>

<footer>
    <span id="lblLanguage">Ng√¥n ng·ªØ:</span>
    <select onchange="changeLang(this.value)"><option value="vi">üáªüá≥ VI</option><option value="en">üá¨üáß EN</option></select>
</footer>

<script>
// Canvas Polyfill
if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
        if (w < 2 * r) r = w / 2; if (h < 2 * r) r = h / 2;
        this.beginPath(); this.moveTo(x + r, y); this.arcTo(x + w, y, x + w, y + h, r);
        this.arcTo(x + w, y + h, x, y + h, r); this.arcTo(x, y + h, x, y, r); this.arcTo(x, y, x + w, y, r);
        this.closePath(); return this;
    }
}

// ================================================================
// AI INTEGRATION MODULE
// ================================================================
let isAiConnected = false;
let aiApiKey = "";
let aiProvider = "gemini";
let aiLogs = [];

function getAiProviderSelect(tab) {
    return document.getElementById(tab === 'pose' ? 'aiProviderPose' : 'aiProviderAnime');
}

function syncProviderUI() {
    ['anime','pose'].forEach(tab => {
        let sel = getAiProviderSelect(tab);
        if(sel) {
            sel.value = aiProvider;
            if(sel.updateCustomUI) sel.updateCustomUI();
        }
    });
}

function applyAiThemeMode() {
    document.body.classList.toggle('ai-theme', isAiConnected);
    document.body.classList.toggle('gemini-neon', isAiConnected && aiProvider === 'gemini');
}

function syncAiProviderFrom(tab) {
    const selectedProvider = getAiProviderSelect(tab).value;
    if(selectedProvider === aiProvider) return;

    if(isAiConnected) {
        const wantsDisconnect = confirm(currentLang === 'vi'
            ? 'ƒê·ªïi m√¥ h√¨nh s·∫Ω ng·∫Øt k·∫øt n·ªëi AI hi·ªán t·∫°i. B·∫°n c√≥ mu·ªën ti·∫øp t·ª•c kh√¥ng?'
            : 'Changing model will disconnect the current AI session. Continue?');
        if(!wantsDisconnect) {
            syncProviderUI();
            return;
        }
        disconnectAi(true);
    }

    aiProvider = selectedProvider;
    syncProviderUI();
    addAiLog('config', `Provider switched to ${aiProvider}`);
}

function escapeHtml(str) {
    return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
}

function addAiLog(type, message) {
    const stamp = new Date().toLocaleTimeString('vi-VN', { hour12: false });
    const rawMsg = String(message);
    aiLogs.unshift({ stamp, type, message: rawMsg });
    aiLogs = aiLogs.slice(0, 40);
    const box = document.getElementById('aiLogList');
    if(!box) return;
    box.innerHTML = aiLogs.map(item => {
        const level = item.type.startsWith('response') ? 'response' : item.type.startsWith('error') ? 'error' : 'request';
        const cleanMsg = escapeHtml(item.message);
        const msgHtml = `<div>${cleanMsg}</div>`;
        return `<div class="ai-log-item log-${level}">
            <div class="ai-log-meta"><span class="ai-log-type">${escapeHtml(item.type)}</span><span class="ai-log-time">${escapeHtml(item.stamp)}</span></div>
            <div class="ai-log-msg">${msgHtml}</div>
        </div>`;
    }).join('');
}

function summarizeForLog(value, maxLen = 180) {
    const compact = String(value || '')
        .replace(/\s+/g, ' ')
        .replace(/[{}\[\]"]+/g, '')
        .trim();
    return compact.length > maxLen ? `${compact.slice(0, maxLen)}...` : compact;
}

function buildAiSystemInstruction() {
    return [
        'B·∫°n l√† engine logic trong web tool t√≠nh to√°n.',
        'Ch·ªâ x·ª≠ l√Ω d·ªØ li·ªáu ng∆∞·ªùi d√πng cung c·∫•p, kh√¥ng tr·∫£ l·ªùi ngo√†i ph·∫°m vi.',
        'Kh√¥ng c·∫£m x√∫c, kh√¥ng markdown, kh√¥ng icon, kh√¥ng vƒÉn b·∫£n th·ª´a.',
        'B·∫ÆT BU·ªòC tr·∫£ JSON h·ª£p l·ªá theo format:',
        '{"status":"success|error","analysis":"ng·∫Øn","result":"k·∫øt qu·∫£ ch√≠nh","confidence":"high|medium|low"}',
        'N·∫øu thi·∫øu d·ªØ li·ªáu th√¨ status=error, result=null, confidence=low.',
        'V·ªõi b√†i to√°n n√†y, result PH·∫¢I l√† m·∫£ng s·ªë nguy√™n keyframe (v√≠ d·ª• [1,5,9]).'
    ].join(' ');
}

function playGeminiSpread(sourceEl) {
    const wrap = document.getElementById('toolGeminiBurst');
    if(!wrap) return;
    const hostRect = wrap.getBoundingClientRect();
    const srcRect = sourceEl?.getBoundingClientRect?.() || hostRect;
    const cx = Math.max(10, Math.min(hostRect.width - 10, (srcRect.left + srcRect.width / 2) - hostRect.left));
    const cy = Math.max(10, Math.min(hostRect.height - 10, (srcRect.top + srcRect.height / 2) - hostRect.top));

    const ring = document.createElement('span');
    ring.className = 'gem-ring';
    ring.style.left = `${cx}px`;
    ring.style.top = `${cy}px`;
    wrap.appendChild(ring);
    setTimeout(() => ring.remove(), 2000);

    for(let i = 0; i < 42; i++) {
        const angle = (Math.PI * 2 * i) / 42;
        const radius = 85 + Math.random() * 250;
        const star = document.createElement('span');
        star.className = 'gem-star';
        star.style.left = `${cx}px`;
        star.style.top = `${cy}px`;
        star.style.setProperty('--dx', `${Math.cos(angle) * radius}px`);
        star.style.setProperty('--dy', `${Math.sin(angle) * radius}px`);
        star.style.animationDelay = `${Math.random() * 0.16}s`;
        wrap.appendChild(star);
        setTimeout(() => star.remove(), 2300);
    }
}

async function validateAiKey(provider, key) {
    try {
        if(provider === 'gemini') {
            const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${key}`);
            const data = await res.json();
            if(!res.ok || data.error) throw new Error(data.error?.message || 'Gemini key invalid');
        } else {
            const res = await fetch('https://api.openai.com/v1/models', { headers: { Authorization: `Bearer ${key}` } });
            const data = await res.json();
            if(!res.ok || data.error) throw new Error(data.error?.message || 'OpenAI key invalid');
        }
        return true;
    } catch (e) {
        addAiLog('error', e.message);
        alert((currentLang === 'vi' ? 'Kh√¥ng x√°c th·ª±c ƒë∆∞·ª£c API Key: ' : 'Failed to verify API Key: ') + e.message);
        return false;
    }
}

function initAI() {
    let savedKey = localStorage.getItem("aiApiKey") || sessionStorage.getItem("aiApiKey");
    if(savedKey) {
        aiApiKey = savedKey;
        aiProvider = localStorage.getItem("aiProvider") || sessionStorage.getItem("aiProvider") || 'gemini';
        isAiConnected = true;
        applyAiThemeMode();
        syncProviderUI();
        addAiLog('system', `Recovered ${aiProvider} connection from browser storage`);
    }
}

async function connectAi() {
    let key = document.getElementById("aiApiKey").value.trim();
    if(!key) { alert(currentLang === 'vi' ? "Vui l√≤ng nh·∫≠p API Key!" : "Please enter API Key!"); return; }

    const activeTab = document.getElementById('animeMode').classList.contains('hidden') ? 'pose' : 'anime';
    aiProvider = getAiProviderSelect(activeTab).value;
    addAiLog('request', `Connecting ${aiProvider}...`);

    const ok = await validateAiKey(aiProvider, key);
    if(!ok) return;

    aiApiKey = key;
    isAiConnected = true;
    const shouldSave = confirm(currentLang === 'vi'
        ? 'K·∫øt n·ªëi th√†nh c√¥ng. B·∫°n c√≥ mu·ªën l∆∞u API tr√™n tr√¨nh duy·ªát n√†y kh√¥ng?'
        : 'Connected successfully. Do you want to remember this API key in this browser?');
    if(shouldSave) {
        localStorage.setItem("aiApiKey", key); localStorage.setItem("aiProvider", aiProvider);
        sessionStorage.removeItem("aiApiKey"); sessionStorage.removeItem("aiProvider");
    } else {
        sessionStorage.setItem("aiApiKey", key); sessionStorage.setItem("aiProvider", aiProvider);
        localStorage.removeItem("aiApiKey"); localStorage.removeItem("aiProvider");
    }
    applyAiThemeMode();
    syncProviderUI();
    if(aiProvider === 'gemini') {
        playGeminiSpread(document.getElementById('globalAiAuth'));
    }
    addAiLog('response', `Connected ${aiProvider}. Persist=${shouldSave ? 'yes' : 'session only'}`);
    toggleAnimePoseInput(); togglePoseSettings(); updateAnime(); updatePoseEst();
}

function disconnectAi(skipNotice = false) {
    aiApiKey = ""; isAiConnected = false;
    localStorage.removeItem("aiApiKey"); localStorage.removeItem("aiProvider");
    sessionStorage.removeItem("aiApiKey"); sessionStorage.removeItem("aiProvider");
    document.getElementById("aiApiKey").value = "";
    applyAiThemeMode();
    addAiLog('system', 'Disconnected AI service and cleared local/session key');
    if(!skipNotice) {
        alert(currentLang === 'vi' ? 'ƒê√£ ng·∫Øt k·∫øt n·ªëi AI.' : 'AI disconnected.');
    }
    toggleAnimePoseInput(); togglePoseSettings(); updateAnime(); updatePoseEst();
}

function injectAiUI(tabId, isAI) {
    let authBlock = document.getElementById("globalAiAuth");
    let pill = document.getElementById("globalAiPill");
    let logPanel = document.getElementById('aiLogPanel');
    let logicRow = document.getElementById(tabId === 'anime' ? "rowLogicA" : "rowLogicP");
    let modePanel = document.getElementById(tabId === 'anime' ? 'animeMode' : 'poseMode');

    if(isAI) {
        if(modePanel && logPanel && logPanel.parentElement !== modePanel) modePanel.appendChild(logPanel);
        logPanel.classList.remove('hidden');
        if(!document.getElementById('aiLogList').innerHTML.trim()) {
            addAiLog('system', currentLang === 'vi' ? 'Log AI ƒëang b·∫≠t tr√™n thi·∫øt b·ªã n√†y.' : 'AI log is active on this device.');
        }
        if(!isAiConnected) {
            logicRow.after(authBlock); authBlock.classList.remove("hidden"); pill.classList.add("hidden");
        } else {
            authBlock.classList.add("hidden"); logicRow.after(pill); pill.classList.remove("hidden");
            document.getElementById("aiProviderName").innerText = aiProvider === 'gemini' ? 'Gemini' : 'ChatGPT';
        }
    } else {
        authBlock.classList.add("hidden");
        pill.classList.add("hidden");
        logPanel.classList.add('hidden');
    }
}

async function fetchAiKeys(promptText) {
    const systemInstruction = buildAiSystemInstruction();
    const bodyGemini = {
        systemInstruction: { parts: [{ text: systemInstruction }] },
        contents: [{ parts: [{ text: promptText }] }],
        generationConfig: { response_mime_type: "application/json" }
    };
    const bodyGPT = {
        model: "gpt-4o-mini",
        messages: [
            { role: "system", content: systemInstruction },
            { role: "user", content: promptText }
        ],
        response_format: { type: "json_object" }
    };
    try {
        let res, data, keys;
        addAiLog('request.prompt', `Input summary: ${summarizeForLog(promptText)}`);
        addAiLog('request.provider', aiProvider);
        addAiLog('request.http', aiProvider === 'gemini'
            ? 'POST https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent'
            : 'POST https://api.openai.com/v1/chat/completions');
        if (aiProvider === 'gemini') {
            addAiLog('request.body', `system+payload sent (${JSON.stringify(bodyGemini).length} chars)`);
            res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${aiApiKey}`, {
                method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(bodyGemini)
            });
            data = await res.json();
            if(data.error) throw new Error(data.error.message);
            let text = data.candidates?.[0]?.content?.parts?.[0]?.text || '{}';
            let parsed = JSON.parse(text);
            keys = parsed.result || parsed.keys || parsed;
            addAiLog('response.raw', `status=${parsed.status || 'n/a'}, confidence=${parsed.confidence || 'n/a'}, result=${summarizeForLog(JSON.stringify(parsed.result || parsed.keys || null), 120)}`);
        } else {
            addAiLog('request.body', `system+payload sent (${JSON.stringify(bodyGPT).length} chars)`);
            res = await fetch(`https://api.openai.com/v1/chat/completions`, {
                method: "POST", headers: { "Content-Type": "application/json", "Authorization": `Bearer ${aiApiKey}` }, body: JSON.stringify(bodyGPT)
            });
            data = await res.json();
            if(data.error) throw new Error(data.error.message);
            const content = data.choices?.[0]?.message?.content || '{}';
            let parsed = JSON.parse(content);
            keys = parsed.result || parsed.keys || parsed;
            addAiLog('response.raw', `status=${parsed.status || 'n/a'}, confidence=${parsed.confidence || 'n/a'}, result=${summarizeForLog(JSON.stringify(parsed.result || parsed.keys || null), 120)}`);
        }
        return Array.isArray(keys) ? keys : null;
    } catch (e) {
        addAiLog('error', e.message);
        alert((currentLang === 'vi' ? "L·ªói k·∫øt n·ªëi AI: " : "AI Connection Error: ") + e.message); return null;
    }
}

async function generateWithAi(tab) {
    let btn = document.getElementById("btnGenerateAi" + (tab==='anime'?'A':'P'));
    let oriText = btn.innerHTML;
    btn.innerHTML = currentLang === 'vi' ? "‚ú® ƒêang x·ª≠ l√Ω d·ªØ li·ªáu..." : "‚ú® Processing data...";
    btn.disabled = true;

    let promptText = "";
    if (tab === 'anime') {
        let sfRaw = parseInt(document.getElementById("startFrame").value); let efRaw = parseInt(document.getElementById("endFrame").value);
        let sf = isNaN(sfRaw) ? 1 : Math.min(sfRaw, isNaN(efRaw)?100:efRaw); let ef = isNaN(efRaw) ? 100 : Math.max(sfRaw||1, efRaw);
        let style = document.getElementById("animStyle").value; let poses = document.getElementById("poseCount").value || 5;
        let pacing = document.getElementById("corePacingAnime").value; let curve = document.getElementById("curveTypeAnime").value;
        promptText = `Nhi·ªám v·ª•: t√≠nh keyframe ch√≠nh cho animation. D·ªØ li·ªáu: start_frame=${sf}, end_frame=${ef}, style_on=${style}, key_pose_target=${poses}, pacing=${pacing}, curve=${curve}. Xu·∫•t JSON chu·∫©n, result l√† m·∫£ng s·ªë nguy√™n keyframe.`;
    } else {
        let secRaw = parseFloat(document.getElementById("poseSeconds").value); let sec = isNaN(secRaw) || secRaw <= 0 ? 1 : secRaw;
        let fps = parseFloat(document.getElementById("fpsPose").value) || 24; let style = document.getElementById("animStylePose").value;
        let focus = document.getElementById("focusTypePose").value; let action = focus === 'char' ? document.getElementById("focusActionChar").value : document.getElementById("focusActionObj").value;
        let pacing = document.getElementById("corePacingPose").value; let totalFrames = Math.max(1, Math.round(sec * fps));
        promptText = `Nhi·ªám v·ª•: ∆∞·ªõc t√≠nh keyframe ch√≠nh. D·ªØ li·ªáu: seconds=${sec}, fps=${fps}, total_frames=${totalFrames}, style_on=${style}, focus=${focus}, action=${action}, pacing=${pacing}. Xu·∫•t JSON chu·∫©n, result l√† m·∫£ng s·ªë nguy√™n keyframe.`;
    }

    let keys = await fetchAiKeys(promptText);
    btn.innerHTML = oriText; btn.disabled = false;

    if (keys && keys.length > 0) {
        if(tab === 'anime') updateAnime(keys);
        else updatePoseEst(keys);
    }
}
// ================================================================

let currentLang = "vi";

const i18n = {
    vi: {
        introText: "C√¥ng c·ª• ƒëa nƒÉng h·ªó tr·ª£ Animation Timing, T√≠nh to√°n Frame v√† Render.",
        tabConvert: "Time / Frame", tabAnime: "Anime, Toon Frame", tabPose: "D·ª± t√≠nh Pose", tabRender: "Render Time",
        descConvert: "C√¥ng c·ª• chuy·ªÉn ƒë·ªïi qua l·∫°i gi·ªØa th·ªùi l∆∞·ª£ng (Gi√¢y/Ph√∫t/Gi·ªù) v√† S·ªë khung h√¨nh (Frames) theo t·ªëc ƒë·ªô chu·∫©n.",
        descAnime: "Ph√¢n b·ªï kho·∫£ng c√°ch c√°c Keyframe theo quy t·∫Øc Animation (On 1s, 2s, 3s) v√† n·ªôi suy nh·ªãp ƒë·ªô c·∫£nh.",
        descPose: "T·ª± ƒë·ªông ∆∞·ªõc t√≠nh s·ªë l∆∞·ª£ng Pose ch√≠nh v√† Pose ph·ª• tr·ª£ (In-betweens) ph·ª• thu·ªôc v√†o h√†nh ƒë·ªông c·ª• th·ªÉ v√† th·ªùi l∆∞·ª£ng.",
        descRender: "∆Ø·ªõc t√≠nh t·ªïng th·ªùi gian xu·∫•t file (Render) c·ªßa to√†n b·ªô d·ª± √°n d·ª±a tr√™n th·ªùi gian ch·∫°y 1 khung h√¨nh.",

        tipMode: "Ch·ªçn lo·∫°i chuy·ªÉn ƒë·ªïi.", tipFPS_conv: "T·ªëc ƒë·ªô khung h√¨nh (th∆∞·ªùng l√† 24).", tipInput: "Nh·∫≠p t·ªïng s·ªë l∆∞·ª£ng t√≠nh to√°n.",
        tipAnimStyle: "Quy ƒë·ªãnh s·ªë b·∫£n v·∫Ω tr√™n gi√¢y:\n‚Ä¢ On 1s: 24 fps (M∆∞·ª£t).\n‚Ä¢ On 2s: 12 fps (Anime).\n‚Ä¢ On 3s: 8 fps (Ch·∫≠m).",
        tipFPS_anime: "Khung h√¨nh ti√™u chu·∫©n c·ªßa d·ª± √°n.", tipCorePacingAnime: "T·ªëc ƒë·ªô di·ªÖn ho·∫°t c·∫£nh.",
        tipCurveTypeAnime: "ƒê∆∞·ªùng cong t·ªëc ƒë·ªô (Time Remapping):\n‚Ä¢ T√πy ch·ªânh: ƒê·ªì th·ªã t·ªëc ƒë·ªô t√πy ch·ªânh (Y√™u c·∫ßu >3s v√† Logic Nghi√™m ng·∫∑t).",
        tipFocus: "V·∫≠t th·ªÉ ƒëang ƒë·ª©ng im hay di chuy·ªÉn.", tipPose: "T·ªïng s·ªë Pose ch√≠nh c·∫ßn v·∫Ω.", tipFrameRange: "Gi·ªõi h·∫°n th·ªùi gian c·ªßa ƒëo·∫°n di·ªÖn ho·∫°t.",
        tipCalcLogic: "‚Ä¢ Nghi√™m ng·∫∑t: C·ªë ƒë·ªãnh to√°n h·ªçc.\n‚Ä¢ Ng·∫´u nhi√™n: Th√™m sai l·ªách t·ª± nhi√™n.\n‚Ä¢ Tr·ª£ Th·ªß AI: Sinh keyframe t·ª± ƒë·ªông si√™u chu·∫©n b·∫±ng AI.", 
        tipPoseCalcMode: "T·ª± b·ªãa s·ªë gi√¢y hay ·∫•n ƒë·ªãnh tr∆∞·ªõc.", tipPoseSeconds: "ƒê·ªô d√†i c·∫£nh (gi√¢y).",
        tipFPS_pose: "Khung h√¨nh ti√™u chu·∫©n c·ªßa d·ª± √°n.", tipAnimStylePose: "S·ªë frame ƒë·ªÉ gi·ªØ 1 b·∫£n v·∫Ω.", tipFocusTypePose: "Lo·∫°i ƒë·ªëi t∆∞·ª£ng ch√≠nh.",
        tipFocusActionPose: "H√†nh ƒë·ªông ƒë·ªÉ thu·∫≠t to√°n ƒëo ƒë·ªô kh√≥.", tipCorePacingPose: "Nh·ªãp h√†nh ƒë·ªông t·ªïng th·ªÉ.",
        tipCurveTypePose: "Quy lu·∫≠t Easing.\n‚Ä¢ T√πy ch·ªânh: ƒê·ªì th·ªã t·ªëc ƒë·ªô t√πy ch·ªânh (Y√™u c·∫ßu >3s v√† Theo gi√¢y).",
        tipSubPose: "T·ª± ƒë·ªông ch√®n In-betweens.", tipSubPoseLogic: "S·ªë l∆∞·ª£ng b·∫£n v·∫Ω ph·ª• ch√®n gi·ªØa.", tipJerkiness: "K·ªπ thu·∫≠t Hold ·ªü ƒëi·ªÉm ch·∫°m.",
        tipTotalFrames: "T·ªïng frame xu·∫•t.", tipRenderPerFrame: "Th·ªùi gian m√°y render 1 frame.",
        tipForceClampA: "Cho ph√©p d·ªìn keyframe cu·ªëi v√†o khung h√¨nh k·∫øt th√∫c ngay c·∫£ khi l·ªách nh·ªãp. Ch·ªâ n√™n d√πng khi c·∫£nh ƒë·ªß d√†i (>= 1 gi√¢y).",
        tipForceClampP: "Cho ph√©p d·ªìn keyframe cu·ªëi v√†o khung h√¨nh k·∫øt th√∫c ngay c·∫£ khi l·ªách nh·ªãp. Ch·ªâ n√™n d√πng khi c·∫£nh ƒë·ªß d√†i (>= 1 gi√¢y).",

        lblMode: "Lo·∫°i t√≠nh", optF2T: "Frame ‚Üí Time", optT2F: "Time ‚Üí Frame",
        lblFPS_conv: "FPS", lblInput: "S·ªë khung h√¨nh/th·ªùi gian", optSec: "Gi√¢y", optMin: "Ph√∫t", optHour: "Gi·ªù",
        lblAnimStyle: "Ki·ªÉu di·ªÖn ho·∫°t", optOn1s: "On 1s (M∆∞·ª£t / H√†nh ƒë·ªông)", optOn2s: "On 2s (Chu·∫©n Anime)", optOn3s: "On 3s (Tƒ©nh / Ch·∫≠m)",
        lblFPS_anime: "FPS g·ªëc", lblCorePacingAnime: "Nh·ªãp t√¢m ƒëi·ªÉm", 
        optCpSuperSlowA: "Super Slow", optCpSlowmoA: "Slow Motion", optCpSlowA: "Ch·∫≠m", optCpNormalA: "B√¨nh th∆∞·ªùng", optCpFastA: "Nhanh", optCpSuperFastA: "C·ª±c nhanh", optCpTimeSplashA: "Time Splash",
        lblCurveTypeAnime: "Lo·∫°i ƒë·ªì th·ªã (Ph√¢n b·ªï)", optCvNoneA: "Kh√¥ng (ƒê·ªÅu)", optCvEaseOutA: "ƒê·ªì th·ªã xu·ªëng (Ch·∫≠m d·∫ßn)", optCvEaseInA: "ƒê·ªì th·ªã l√™n (Nhanh d·∫ßn)", optCvClimaxA: "ƒêi·ªÉm cao tr√†o (Nhanh gi·ªØa)", optCvLowPointA: "ƒêi·ªÉm tr·∫ßm (Ch·∫≠m gi·ªØa)", optCvWaveA: "S√≥ng (Nhanh ch·∫≠m xen k·∫Ω)", optCvCustomA: "T√πy ch·ªânh (ƒê·ªì th·ªã t·ªëc ƒë·ªô)",
        lblFocus: "T√¢m ƒëi·ªÉm & Tr·∫°ng th√°i", optFocScene: "C·∫£nh", optFocChar: "Nh√¢n v·∫≠t/V·∫≠t th·ªÉ", optStateStatic: "Tƒ©nh", optStateDynamic: "ƒê·ªông",
        lblPose: "S·ªë Pose ch√≠nh", lblFrameRange: "Frame B·∫Øt ƒë·∫ßu - K·∫øt th√∫c", 
        
        lblCalcLogic: "Logic t√≠nh to√°n", optLogicStrict: "To√°n h·ªçc nghi√™m ng·∫∑t", optLogicRandom: "X√°c su·∫•t ng·∫´u nhi√™n", optLogicAI_A: "‚ú® Tr·ª£ Th·ªß AI",
        lblPoseCalcMode: "Logic t√≠nh to√°n", optPcalcSeconds: "Theo s·ªë gi√¢y c·∫£nh (To√°n h·ªçc)", optPcalcRandom: "X√°c su·∫•t ng·∫´u nhi√™n", optLogicAI_P: "‚ú® Tr·ª£ Th·ªß AI",
        
        warnMathModelAnime: "‚ö† L∆∞u √Ω: M√¥ h√¨nh ƒë·ªì th·ªã v√† to√°n h·ªçc ch·ªâ mang t√≠nh ch·∫•t g·ª£i √Ω tham kh·∫£o.",
        lblPoseSeconds: "Nh·∫≠p s·ªë gi√¢y c·∫£nh", lblFPS_pose: "FPS g·ªëc", lblAnimStylePose: "Lo·∫°i di·ªÖn ho·∫°t",
        lblFocusTypePose: "Lo·∫°i t√¢m ƒëi·ªÉm", optFocCharP: "Nh√¢n v·∫≠t", optFocObjP: "V·∫≠t th·ªÉ",
        lblFocusActionPose: "H√†nh ƒë·ªông c·ª• th·ªÉ", actTalk: "N√≥i chuy·ªán", actWalk: "ƒêi b·ªô", actRun: "Ch·∫°y", actFight: "ƒê√°nh nhau", actOtherC: "H√†nh ƒë·ªông kh√°c", actFly: "Bay", actFall: "R∆°i", actBreak: "V·ª°/G√£y", actBounce: "N·∫£y", actScale: "Scale", actOtherO: "H√†nh ƒë·ªông kh√°c",
        lblCorePacingPose: "Nh·ªãp t√¢m ƒëi·ªÉm", optCpSuperSlowP: "Super Slow", optCpSlowmoP: "Slow Motion", optCpSlowP: "Ch·∫≠m", optCpNormalP: "B√¨nh th∆∞·ªùng", optCpFastP: "Nhanh", optCpSuperFastP: "C·ª±c nhanh", optCpTimeSplashP: "Time Splash",
        lblCurveTypePose: "Lo·∫°i ƒë·ªì th·ªã", optCvNoneP: "Kh√¥ng", optCvEaseOutP: "ƒê·ªì th·ªã xu·ªëng", optCvEaseInP: "ƒê·ªì th·ªã l√™n", optCvClimaxP: "ƒêi·ªÉm cao tr√†o", optCvLowPointP: "ƒêi·ªÉm tr·∫ßm", optCvWaveP: "S√≥ng", optCvCustomP: "T√πy ch·ªânh (ƒê·ªì th·ªã t·ªëc ƒë·ªô)",
        lblSubPose: "Pose ph·ª• (In-betweens)", optNo: "Kh√¥ng", optYes: "C√≥",
        lblSubPoseLogic: "Quy t·∫Øc Pose ph·ª•", optSpRandom: "Ng·∫´u nhi√™n",
        lblJerkiness: "Gi·∫≠t/Kh·ª±ng (Hold)", optJerkNo: "Kh√¥ng", optJerkFrame: "Theo Frame", optJerkSec: "Theo Gi√¢y",
        warnMathModelPose: "‚ö† L∆∞u √Ω: H·ªá th·ªëng ch·ªâ t√≠nh to√°n g·ª£i √Ω v·ªã tr√≠ l√Ω thuy·∫øt, m·∫≠t ƒë·ªô th·ª±c t·∫ø ph·ª• thu·ªôc b·∫£n v·∫Ω.",
        lblTotalFrames: "T·ªïng frame", lblRenderPerFrame: "Th·ªùi gian render 1 frame (gi√¢y)",
        warningTextRender: "‚ö† Th·ª±c t·∫ø c·∫£nh n·∫∑ng s·∫Ω thay ƒë·ªïi th·ªùi gian.", lblLanguage: "Ng√¥n ng·ªØ:",
        
        lblForceClampA: "√âp Key cu·ªëi", lblForceClampP: "√âp Key cu·ªëi",
        optFCN_A: "Kh√¥ng", optFCY_A: "C√≥", optFCN_P: "Kh√¥ng", optFCY_P: "C√≥",
        lblCustomPreview: "B·∫£n sao: T·ªïng quan (Gia t·ªëc)",
        
        dynFrames: "frames", dynSec: "gi√¢y", dynKeysSugg: "G·ª£i √Ω Keyframe", dynEstPoses: "Pose ∆∞·ªõc t√≠nh",
        dynTotal: "T·ªïng:",
        dynSubPose: "Pose ph·ª•", dynHold: "Gi·∫≠t/Kh·ª±ng (Hold)", dynHoldMsg1: "Khuy√™n d√πng gi·ªØ th√™m", dynHoldMsg2: "t·∫°i ƒëi·ªÉm ch·∫°m.",
        dynHintFrames: "G·ª£i √Ω h·ª£p l√Ω: ",
        dynHoldCapNote: "(ƒê√£ gi·∫£m xu·ªëng t·ªëi ƒëa 40% c·∫£nh ƒë·ªÉ gi·ªØ nh·ªãp)",
        
        dynForceSafe1: "L∆∞u √Ω: Keyframe cu·ªëi b·ªã √©p v√†o frame", 
        dynForceSafe2: "theo t√πy ch·ªçn c·ªßa b·∫°n. ƒêi·ªÅu n√†y ho√†n to√†n ·ªïn v·ªõi th·ªùi gian b·∫°n ch·ªçn.",
        
        dynClampWarn1: "‚ö†Ô∏è L∆∞u √Ω: Th·ªùi gian c·∫£nh qu√° ng·∫Øn ho·∫∑c nh·ªãp ƒëi·ªáu kh√¥ng kh·ªõp ho√†n to√†n. Keyframe cu·ªëi b·ªã √©p v√†o frame ", dynClampWarn2: " (ph√° v·ª° chu·∫©n nh·ªãp On ", dynClampWarn3: "s).",
        dynSuggestFrame1: "G·ª£i √Ω: ƒê·∫∑t End Frame th√†nh", dynSuggestFrame2: "ho·∫∑c", dynSuggestFrame3: "ƒë·ªÉ kh√¥ng b·ªã l·ªách nh·ªãp.",
        dynSuggestSec1: "G·ª£i √Ω: ƒê·∫∑t th·ªùi gian th√†nh", dynSuggestSec2: "ho·∫∑c",
        
        dynGraphLimitWarn: "‚ö†Ô∏è C·∫£nh b√°o: V∆∞·ª£t qu√° 25 gi√¢y. ƒê√£ ·∫©n bi·ªÉu ƒë·ªì ƒë·ªì th·ªã ƒë·ªÉ t·ªëi ∆∞u h√≥a hi·ªáu su·∫•t thi·∫øt b·ªã.",
        dynMissingPose: "‚ö†Ô∏è L∆∞u √Ω: B·ªã tr√πng l·∫∑p frame do kho·∫£ng c√°ch qu√° s√°t, s·ªë keyframe b·ªã m·∫•t:",
        dynSubBetween: "L√≥t gi·ªØa",
        dynSubNoSlot: "‚ö†Ô∏è Kh√¥ng ƒë·ªß kho·∫£ng tr·ªëng ƒë·ªÉ ch√®n Pose ph·ª• gi·ªØa",
        dynStaticTitle: "Tr·∫°ng th√°i Tƒ©nh (Static)",
        dynStaticDesc: "C·∫ßn v·∫Ω 1 Pose duy nh·∫•t",
        dynStaticHold: "v√† gi·ªØ xuy√™n su·ªët",
        
        lblVisualGraph: "T·ªïng quan (Gia t·ªëc)", tipVisualGraph: "ƒê·ªì th·ªã bi·ªÉu di·ªÖn ph√¢n b·ªï t·ªëc ƒë·ªô l√Ω thuy·∫øt. ƒê∆∞·ªùng n√©t ƒë·ª©t l√† m·ªëc t·ªëc ƒë·ªô ƒë·ªÅu ƒë·∫∑n.",
        lblDataGraph: "D√≤ng th·ªùi gian (Keyframe)", tipDataGraph: "V·ªã tr√≠ th·ª±c t·∫ø c·ªßa t·ª´ng b·∫£n v·∫Ω tr√™n tr·ª•c th·ªùi gian (K√©o sang ph·∫£i ƒë·ªÉ xem h·∫øt).",
        phStartFrame: "B·∫Øt ƒë·∫ßu (vd: 1)", phEndFrame: "K·∫øt th√∫c (vd: 100)",
        legendMainKey: "Key ch√≠nh", legendSubKey: "Key ph·ª•",
        lblEditorA: "Time Remapping", lblEditorP: "Time Remapping", lblLockA: "Kh√≥a m√∫t", lblLockP: "Kh√≥a m√∫t", lblSmoothA: "M∆∞·ª£t", lblSmoothP: "M∆∞·ª£t", btnResetA: "ƒê·∫∑t l·∫°i", btnResetP: "ƒê·∫∑t l·∫°i",
        
        warnCustomAnime: "‚ö†Ô∏è T√πy ch·ªânh kh√¥ng kh·∫£ d·ª•ng: \"Logic t√≠nh to√°n\" c·∫ßn ch·ªçn To√°n h·ªçc nghi√™m ng·∫∑t v√† th·ªùi l∆∞·ª£ng t·ª´ 3 gi√¢y.",
        warnCustomPose: "‚ö†Ô∏è T√πy ch·ªânh kh√¥ng kh·∫£ d·ª•ng: \"Logic t√≠nh to√°n\" c·∫ßn ch·ªçn Theo s·ªë gi√¢y c·∫£nh v√† th·ªùi l∆∞·ª£ng t·ª´ 3 gi√¢y.",
        
        lblAiProvider: "D·ªãch v·ª• AI", lblAiKey: "API Key", phAiKey: "Nh·∫≠p m√£ API Key c·ªßa b·∫°n...", lblAiSave: "Nh·ªõ m√£ k·∫øt n·ªëi tr√™n thi·∫øt b·ªã n√†y",
        btnConnectAi: "K·∫øt n·ªëi Tr·ª£ Th·ªß AI", btnDisconnectAi: "Ng·∫Øt k·∫øt n·ªëi", txtAiConnected: "‚ú® ƒê√£ k·∫øt n·ªëi v·ªõi",
        txtBtnGenA: "‚ú® T·ª± ƒë·ªông t·∫°o b·∫±ng AI", txtBtnGenP: "‚ú® ∆Ø·ªõc t√≠nh s·ªë l∆∞·ª£ng (AI)",
        txtAiReady: "‚ú® S·∫µn s√†ng. H√£y t√πy ch·ªânh th√¥ng s·ªë b√™n tr√™n v√† b·∫•m n√∫t t·∫°o AI."
    },
    en: {
        introText: "Versatile tool for Animation Timing, Frame calculations, and Render estimation.",
        tabConvert: "Time / Frame", tabAnime: "Anime, Toon Frame", tabPose: "Pose Estimator", tabRender: "Render Time",
        descConvert: "Tool to seamlessly convert between time duration (Sec/Min/Hour) and total Frames based on FPS.",
        descAnime: "Distribute Keyframes using standard Animation rules (On 1s, 2s, 3s) and calculate scene pacing.",
        descPose: "Automatically estimate main Poses and In-betweens depending on specific action types and duration.",
        descRender: "Estimate the total Render time needed for your project based on a single frame's processing time.",
        
        tipMode: "Select conversion type.", tipFPS_conv: "FPS determines the speed.", tipInput: "Enter the value to compute.",
        tipAnimStyle: "Defines keys per second.", tipFPS_anime: "Standard framerate.", tipCorePacingAnime: "Overall scene speed.",
        tipCurveTypeAnime: "Acceleration curve.\n‚Ä¢ Custom: Custom Speed Curve (Requires >3s & Strict Logic).",
        tipFocus: "Dynamic (moving) or Static (still).", tipPose: "Number of main poses.", tipFrameRange: "Time boundary.",
        tipCalcLogic: "Strict math, Random deviation, or AI powered.", tipPoseCalcMode: "Math calculation or AI powered.", tipPoseSeconds: "Desired duration.",
        tipFPS_pose: "Standard framerate.", tipAnimStylePose: "Keyframe density.", tipFocusTypePose: "Character or Object.",
        tipFocusActionPose: "Specific action.", tipCorePacingPose: "Overall speed.",
        tipCurveTypePose: "Acceleration curve.\n‚Ä¢ Custom: Custom Speed Curve (Requires >3s & Fixed Seconds).",
        tipSubPose: "Generate In-between poses.", tipSubPoseLogic: "In-between padding rule.", tipJerkiness: "Hold frames at impact.",
        tipTotalFrames: "Total frames to render.", tipRenderPerFrame: "Actual time to render a single frame.",
        tipForceClampA: "Force the last keyframe to snap to the end frame even if it breaks rhythm.",
        tipForceClampP: "Force the last keyframe to snap to the end frame even if it breaks rhythm.",

        lblMode: "Mode", optF2T: "Frame ‚Üí Time", optT2F: "Time ‚Üí Frame",
        lblFPS_conv: "FPS", lblInput: "Input Value", optSec: "Seconds", optMin: "Minutes", optHour: "Hours",
        lblAnimStyle: "Anim Style", optOn1s: "On 1s", optOn2s: "On 2s", optOn3s: "On 3s",
        lblFPS_anime: "Base FPS", lblCorePacingAnime: "Core Pacing", 
        optCpSuperSlowA: "Super Slow", optCpSlowmoA: "Slow Motion", optCpSlowA: "Slow", optCpNormalA: "Normal", optCpFastA: "Fast", optCpSuperFastA: "Super Fast", optCpTimeSplashA: "Time Splash",
        lblCurveTypeAnime: "Curve Type", optCvNoneA: "None (Linear)", optCvEaseOutA: "Ease Out", optCvEaseInA: "Ease In", optCvClimaxA: "Climax", optCvLowPointA: "Low Point", optCvWaveA: "Wave", optCvCustomA: "Custom (Speed Curve)",
        lblFocus: "Focus & State", optFocScene: "Scene", optFocChar: "Character/Object", optStateStatic: "Static", optStateDynamic: "Dynamic",
        lblPose: "Pose Count", lblFrameRange: "Start - End Frame", 
        
        lblCalcLogic: "Logic", optLogicStrict: "Strict Math", optLogicRandom: "Random Prob", optLogicAI_A: "‚ú® AI Assistant",
        lblPoseCalcMode: "Logic", optPcalcSeconds: "By Scene Seconds (Math)", optPcalcRandom: "Random Prob", optLogicAI_P: "‚ú® AI Assistant",
        
        warnMathModelAnime: "‚ö† Note: Graph models are for theoretical reference only.",
        lblPoseSeconds: "Enter Seconds", lblFPS_pose: "Base FPS", lblAnimStylePose: "Anim Style",
        lblFocusTypePose: "Focus Type", optFocCharP: "Character", optFocObjP: "Object",
        lblFocusActionPose: "Specific Action", actTalk: "Talking", actWalk: "Walking", actRun: "Running", actFight: "Fighting", actOtherC: "Other Action", actFly: "Flying", actFall: "Falling", actBreak: "Breaking", actBounce: "Bouncing", actScale: "Scaling", actOtherO: "Other Action",
        lblCorePacingPose: "Core Pacing", optCpSuperSlowP: "Super Slow", optCpSlowmoP: "Slow Motion", optCpSlowP: "Slow", optCpNormalP: "Normal", optCpFastP: "Fast", optCpSuperFastP: "Super Fast", optCpTimeSplashP: "Time Splash",
        lblCurveTypePose: "Curve Type", optCvNoneP: "None", optCvEaseOutP: "Ease Out", optCvEaseInP: "Ease In", optCvClimaxP: "Climax", optCvLowPointP: "Low Point", optCvWaveP: "Wave", optCvCustomP: "Custom (Speed Curve)",
        lblSubPose: "Add In-betweens", optNo: "No", optYes: "Yes", lblSubPoseLogic: "In-between Logic", optSpRandom: "Random Prob",
        lblJerkiness: "Stutter / Hold", optJerkNo: "No", optJerkFrame: "By Frames", optJerkSec: "By Seconds",
        warnMathModelPose: "‚ö† Note: Theoretical suggestion; real density depends on the drawing.",
        lblTotalFrames: "Total Frames", lblRenderPerFrame: "Time per frame",
        warningTextRender: "‚ö† Reference only.", lblLanguage: "Language:",
        
        lblForceClampA: "Force Clamp", lblForceClampP: "Force Clamp",
        optFCN_A: "No", optFCY_A: "Yes", optFCN_P: "No", optFCY_P: "Yes",
        lblCustomPreview: "Preview: Overview (Acceleration)",
        
        dynFrames: "Frames", dynSec: "sec", dynKeysSugg: "Suggested Keys", dynEstPoses: "Est. Main Poses",
        dynTotal: "Total:",
        dynSubPose: "Sub Poses", dynHold: "Hold Effect", dynHoldMsg1: "Suggested holding", dynHoldMsg2: "at impact.", dynHintFrames: "Suggested range: ",
        dynHoldCapNote: "(Capped at 40% of scene to preserve rhythm)",
        
        dynForceSafe1: "Note: The last keyframe was forced to frame",
        dynForceSafe2: "by your choice. This is perfectly fine given your selected duration.",
        
        dynClampWarn1: "‚ö†Ô∏è Note: Scene duration is too short or pacing is mismatched. The last key was forced to frame ", dynClampWarn2: " (breaking the On ", dynClampWarn3: "s rhythm).",
        dynSuggestFrame1: "Suggestion: Set End Frame to", dynSuggestFrame2: "or", dynSuggestFrame3: "to prevent rhythm break.",
        dynSuggestSec1: "Suggestion: Set duration to", dynSuggestSec2: "or",
        
        dynGraphLimitWarn: "‚ö†Ô∏è Warning: Scene > 25s. Graphs disabled to optimize device performance.",
        dynMissingPose: "‚ö†Ô∏è Note: Duplicate frames due to tight spacing ‚Äî poses lost:",
        dynSubBetween: "Between",
        dynSubNoSlot: "‚ö†Ô∏è Not enough space to insert sub poses between",
        dynStaticTitle: "Static State",
        dynStaticDesc: "Draw 1 single Pose",
        dynStaticHold: "and hold for",
        
        lblVisualGraph: "Overview (Acceleration)", tipVisualGraph: "Theoretical speed distribution. Dotted line is constant speed.", 
        lblDataGraph: "Timeline (Keyframes)", tipDataGraph: "Actual frame placement on the timeline (Scrollable horizontally).",
        phStartFrame: "Start (e.g., 1)", phEndFrame: "End (e.g., 100)", legendMainKey: "Main Key", legendSubKey: "Sub Key",
        lblEditorA: "Time Remapping", lblEditorP: "Time Remapping", lblLockA: "Lock Ends", lblLockP: "Lock Ends", lblSmoothA: "Smooth", lblSmoothP: "Smooth", btnResetA: "Reset", btnResetP: "Reset",
        
        warnCustomAnime: "‚ö†Ô∏è Custom not available: \"Logic\" must be Strict Math and duration >= 3 seconds.",
        warnCustomPose: "‚ö†Ô∏è Custom not available: \"Logic\" must be Scene Seconds and duration >= 3 seconds.",
        
        lblAiProvider: "AI Provider", lblAiKey: "API Key", phAiKey: "Enter your API Key...", lblAiSave: "Remember key on this device",
        btnConnectAi: "Connect AI Assistant", btnDisconnectAi: "Disconnect", txtAiConnected: "‚ú® Connected to",
        txtBtnGenA: "‚ú® Auto Generate (AI)", txtBtnGenP: "‚ú® Estimate Poses (AI)",
        txtAiReady: "‚ú® Ready. Set your parameters above and click generate."
    }
};

// ================================================================
// CUSTOM CURVE LOGIC
// ================================================================
let customData = {
    anime: { points: [{x:0, y:0.5}, {x:0.5, y:0.5}, {x:1, y:0.5}], activeNode: null, lut: [] },
    pose:  { points: [{x:0, y:0.5}, {x:0.5, y:0.5}, {x:1, y:0.5}], activeNode: null, lut: [] }
};

function updateCustomLUT(tab) {
    let pts = customData[tab].points; let lut = []; let sum = 0; let steps = 1000;
    let isSmoothEl = document.getElementById("smoothCurve_" + tab);
    let isSmooth = isSmoothEl ? isSmoothEl.checked : true;
    for(let i=0; i<=steps; i++) {
        let x = i / steps;
        let y = isSmooth ? splineCustomCurve(x, pts) : lerpCustomCurve(x, pts);
        y = Math.max(0, Math.min(1, y));
        let speed = Math.pow(10, (y - 0.5) * 2);
        sum += speed; lut.push(sum);
    }
    let total = lut[steps]; if(total === 0) total = 1;
    for(let i=0; i<=steps; i++) lut[i] /= total;
    customData[tab].lut = lut;
}

function resetCustomPoints(tab) {
    customData[tab].points = [{x:0, y:0.5}, {x:0.5, y:0.5}, {x:1, y:0.5}];
    updateCustomLUT(tab); drawCustomEditor(tab);
    if(tab === 'anime') updateAnime(); else updatePoseEst();
}

function lerpCustomCurve(x, points) {
    if(x <= points[0].x) return points[0].y;
    if(x >= points[points.length-1].x) return points[points.length-1].y;
    for(let i=0; i<points.length-1; i++) {
        if(x >= points[i].x && x <= points[i+1].x) {
            let tl = (x - points[i].x) / (points[i+1].x - points[i].x);
            return points[i].y + tl * (points[i+1].y - points[i].y);
        }
    }
    return x;
}

function splineCustomCurve(x, points) {
    if(x <= points[0].x) return points[0].y;
    if(x >= points[points.length-1].x) return points[points.length-1].y;
    let i = 0;
    while(i < points.length - 2 && x > points[i+1].x) i++;
    let p1 = points[i], p2 = points[i+1];
    let p0 = i > 0 ? points[i-1] : { x: p1.x-(p2.x-p1.x), y: p1.y-(p2.y-p1.y) };
    let p3 = i+2 < points.length ? points[i+2] : { x: p2.x+(p2.x-p1.x), y: p2.y+(p2.y-p1.y) };
    let tl = (x - p1.x) / (p2.x - p1.x); let t2 = tl*tl; let t3 = t2*tl;
    let v0 = (p2.y - p0.y) * 0.5; let v1 = (p3.y - p1.y) * 0.5;
    let rawVal = (2*p1.y - 2*p2.y + v0 + v1)*t3 + (-3*p1.y + 3*p2.y - 2*v0 - v1)*t2 + v0*tl + p1.y;
    return Math.max(0, Math.min(1, rawVal));
}

function getPacingCurve(x, type, tab) {
    if(type === 'custom') {
        if(!customData[tab].lut || customData[tab].lut.length === 0) updateCustomLUT(tab);
        let lut = customData[tab].lut; let steps = lut.length - 1;
        let exactIdx = x * steps; let idx1 = Math.floor(exactIdx); let idx2 = Math.ceil(exactIdx);
        if(idx1 < 0) idx1 = 0; if(idx2 > steps) idx2 = steps;
        if(idx1 === idx2) return lut[idx1];
        let tl = exactIdx - idx1; return lut[idx1]*(1-tl) + lut[idx2]*tl;
    }
    if(type === 'ease_in')   return x * x * x;
    if(type === 'ease_out')  return 1 - Math.pow(1-x, 3);
    if(type === 'climax')    return x < 0.5 ? 4*x*x*x : 1 - Math.pow(-2*x+2, 3)/2;
    if(type === 'low_point') return x - 0.15 * Math.sin(x * Math.PI * 2); 
    if(type === 'wave')      return Math.max(0, Math.min(1, x + 0.1 * Math.sin(x * Math.PI * 4)));
    return x;
}

// ================================================================
// CUSTOM CURVE EDITOR DRAWING
// ================================================================
const EDITOR_W = 530;
const EDITOR_H = 140;

function drawCustomEditor(tab) {
    let canvas = document.getElementById("customCanvas_" + tab); if(!canvas) return;
    let dpr = window.devicePixelRatio || 1;
    let w = EDITOR_W, h = EDITOR_H;
    if(canvas.width !== w * dpr) {
        canvas.width = w * dpr; canvas.height = h * dpr;
        canvas.style.width = w + "px"; canvas.style.height = h + "px";
        canvas.getContext("2d").setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    let ctx = canvas.getContext("2d");
    ctx.clearRect(0, 0, w, h);
    
    let padX = 30, padY = 15; let usableW = w - padX * 2; let usableH = h - padY * 2; let midY = h / 2;
    
    ctx.strokeStyle = "rgba(255,255,255,0.06)"; ctx.lineWidth = 1;
    for(let xi = 0; xi <= 4; xi++) { let gx = padX + (xi / 4) * usableW; ctx.beginPath(); ctx.moveTo(gx, padY); ctx.lineTo(gx, h - padY); ctx.stroke(); }
    
    ctx.fillStyle = "rgba(255,255,255,0.35)"; ctx.font = "10px 'Be Vietnam Pro', sans-serif"; ctx.textAlign = "left"; ctx.textBaseline = "middle";
    ctx.fillText("10x", padX + 3, padY + 8); ctx.fillText("1x",  padX + 3, midY - 8); ctx.fillText("0.1x",padX + 3, h - padY - 8);
    
    ctx.beginPath(); ctx.moveTo(padX, midY); ctx.lineTo(w - padX, midY);
    ctx.strokeStyle = "rgba(255, 204, 102, 0.35)"; ctx.setLineDash([4, 4]); ctx.lineWidth = 1.5; ctx.stroke(); ctx.setLineDash([]);
    
    ctx.strokeStyle = "rgba(255,255,255,0.08)"; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(padX, padY); ctx.lineTo(w - padX, padY); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(padX, h - padY); ctx.lineTo(w - padX, h - padY); ctx.stroke();
    
    ctx.beginPath(); ctx.moveTo(padX - 10, h - padY); ctx.lineTo(w - padX + 10, h - padY);
    ctx.strokeStyle = "#1e3a5f"; ctx.lineWidth = 2.5; ctx.stroke();
    
    let pts = customData[tab].points; let isLocked = document.getElementById("lockEnd_" + tab).checked; let isSmooth = document.getElementById("smoothCurve_" + tab).checked;
    
    ctx.beginPath();
    if(isSmooth) {
        ctx.moveTo(padX, h - padY);
        for(let xi = 0; xi <= 1; xi += 0.005) {
            let val = splineCustomCurve(xi, pts); val = Math.max(0, Math.min(1, val));
            ctx.lineTo(padX + xi * usableW, h - padY - val * usableH);
        }
    } else {
        ctx.moveTo(padX, h - padY); pts.forEach(p => { ctx.lineTo(padX + p.x * usableW, h - padY - p.y * usableH); });
    }
    ctx.lineTo(w - padX, h - padY); ctx.closePath();
    ctx.fillStyle = "rgba(0, 204, 255, 0.06)"; ctx.fill();
    
    ctx.beginPath();
    if(isSmooth) {
        let first = true;
        for(let xi = 0; xi <= 1; xi += 0.005) {
            let val = splineCustomCurve(xi, pts); val = Math.max(0, Math.min(1, val));
            let px = padX + xi * usableW; let py = h - padY - val * usableH;
            if(first) { ctx.moveTo(px, py); first = false; } else ctx.lineTo(px, py);
        }
        let lastVal = splineCustomCurve(1, pts); ctx.lineTo(padX + usableW, h - padY - Math.max(0,Math.min(1,lastVal)) * usableH);
    } else {
        pts.forEach((p, i) => {
            let px = padX + p.x * usableW; let py = h - padY - p.y * usableH;
            if(i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
        });
    }
    ctx.strokeStyle = "#00ccff"; ctx.lineWidth = 2.5; ctx.lineCap = "round"; ctx.lineJoin = "round"; ctx.stroke();
    
    pts.forEach((p, i) => {
        let px = padX + p.x * usableW; let py = h - padY - p.y * usableH; let isEndNode = (i === 0 || i === pts.length - 1);
        ctx.beginPath(); ctx.moveTo(px, py); ctx.lineTo(px, h - padY);
        ctx.strokeStyle = "rgba(0, 204, 255, 0.2)"; ctx.lineWidth = 1.5; ctx.stroke();
        
        if(isEndNode && isLocked) {
            ctx.beginPath(); ctx.arc(px, py, 3, 0, Math.PI*2); ctx.fillStyle = "rgba(0, 204, 255, 0.4)"; ctx.fill();
            ctx.beginPath(); ctx.arc(px, h - padY, 4, 0, Math.PI*2); ctx.fillStyle = "rgba(0, 204, 255, 0.3)"; ctx.fill();
        } else {
            ctx.beginPath(); ctx.arc(px, py, 5, 0, Math.PI*2); ctx.fillStyle = "#fff"; ctx.fill();
            ctx.strokeStyle = "rgba(0, 204, 255, 0.6)"; ctx.lineWidth = 1.5; ctx.stroke();
            ctx.beginPath(); ctx.arc(px, h - padY, 5, 0, Math.PI*2); ctx.fillStyle = "#ffcc66"; ctx.fill();
        }
    });
    renderStaticCurve("previewStatic_" + tab, 'custom', tab);
}

function initCustomCanvas(tab) {
    let canvas = document.getElementById("customCanvas_" + tab); if(!canvas || canvas.dataset.initialized) return;
    canvas.dataset.initialized = "true"; let isDragging = false;
    
    canvas.width = EDITOR_W * (window.devicePixelRatio || 1); canvas.height = EDITOR_H * (window.devicePixelRatio || 1);
    canvas.style.width = EDITOR_W + "px"; canvas.style.height = EDITOR_H + "px";
    canvas.getContext("2d").setTransform(window.devicePixelRatio || 1, 0, 0, window.devicePixelRatio || 1, 0, 0);
    
    function getMousePos(e) { let rect = canvas.getBoundingClientRect(); let clientX = e.touches ? e.touches[0].clientX : e.clientX; let clientY = e.touches ? e.touches[0].clientY : e.clientY; return { x: clientX - rect.left, y: clientY - rect.top }; }
    
    function handleDown(e) {
        e.preventDefault(); let pos = getMousePos(e); let padX = 30, padY = 15; let usableW = EDITOR_W - padX*2; let usableH = EDITOR_H - padY*2;
        let pts = customData[tab].points; let isLocked = document.getElementById("lockEnd_" + tab).checked;
        let startIdx = isLocked ? 1 : 0; let endIdx = isLocked ? pts.length - 1 : pts.length;
        for(let i = startIdx; i < endIdx; i++) {
            let px = padX + pts[i].x * usableW; let py = EDITOR_H - padY - pts[i].y * usableH;
            if(Math.hypot(pos.x - px, pos.y - py) < 20) { isDragging = true; customData[tab].activeNode = i; break; }
        }
    }
    
    function handleMove(e) {
        if(!isDragging || customData[tab].activeNode === null) return; e.preventDefault();
        let pos = getMousePos(e); let padX = 30, padY = 15; let usableW = EDITOR_W - padX*2; let usableH = EDITOR_H - padY*2;
        let i = customData[tab].activeNode; let pts = customData[tab].points;
        let newX = (pos.x - padX) / usableW; let newY = (EDITOR_H - padY - pos.y) / usableH;
        if(i === 0) { pts[i].x = 0; pts[i].y = Math.max(0, Math.min(1, newY)); } 
        else if(i === pts.length - 1) { pts[i].x = 1; pts[i].y = Math.max(0, Math.min(1, newY)); } 
        else { let minX = pts[i-1].x + 0.02; let maxX = pts[i+1].x - 0.02; pts[i].x = Math.max(minX, Math.min(maxX, newX)); pts[i].y = Math.max(0, Math.min(1, newY)); }
        updateCustomLUT(tab); drawCustomEditor(tab);
        if(tab === 'anime') updateAnime(); else updatePoseEst();
    }
    
    function handleUp() { isDragging = false; customData[tab].activeNode = null; }
    
    canvas.addEventListener('mousedown', handleDown); canvas.addEventListener('mousemove', handleMove); window.addEventListener('mouseup', handleUp);
    canvas.addEventListener('touchstart', handleDown, {passive:false}); canvas.addEventListener('touchmove', handleMove, {passive:false}); window.addEventListener('touchend', handleUp);
    
    document.getElementById("lockEnd_" + tab).addEventListener('change', () => drawCustomEditor(tab));
    document.getElementById("smoothCurve_" + tab).addEventListener('change', () => { updateCustomLUT(tab); drawCustomEditor(tab); if(tab==='anime') updateAnime(); else updatePoseEst(); });
}

function modifyCustomPoints(tab, delta) {
    let pts = customData[tab].points;
    if(delta > 0 && pts.length < 6) {
        let newPts = [pts[0]];
        for(let i=1; i<pts.length; i++) { newPts.push({ x:(pts[i-1].x+pts[i].x)/2, y:(pts[i-1].y+pts[i].y)/2 }); newPts.push(pts[i]); }
        while(newPts.length > pts.length + 1 && newPts.length > 6) newPts.splice(2, 1);
        customData[tab].points = newPts;
    } else if(delta < 0 && pts.length > 3) { pts.splice(pts.length-2, 1); }
    updateCustomLUT(tab); drawCustomEditor(tab); if(tab === 'anime') updateAnime(); else updatePoseEst();
}

function toggleAnimeCustom() {
    let curve = document.getElementById("curveTypeAnime").value; let logic = document.getElementById("calcLogic").value; let fps = parseFloat(document.getElementById("fpsAnime").value) || 24;
    let sfRaw = parseInt(document.getElementById("startFrame").value); let efRaw = parseInt(document.getElementById("endFrame").value);
    let sfVal = isNaN(sfRaw) ? 1 : sfRaw; let efVal = isNaN(efRaw) ? 100 : efRaw; let sf = Math.min(sfVal, efVal); let ef = Math.max(sfVal, efVal);
    let timeSec = (ef - sf + 1) / fps; let wrap = document.getElementById("customEditorWrap_anime"); let warn = document.getElementById("warnCustomAnime");
    if(curve === "custom") {
        wrap.classList.remove("hidden");
        if(logic !== "strict" || timeSec < 3 || logic === "ai") {
            wrap.classList.add("disabled"); if(warn) { warn.innerText = i18n[currentLang].warnCustomAnime; warn.classList.remove("hidden"); }
        } else {
            wrap.classList.remove("disabled"); if(warn) warn.classList.add("hidden");
            initCustomCanvas('anime'); requestAnimationFrame(() => drawCustomEditor('anime'));
        }
    } else { wrap.classList.add("hidden"); if(warn) warn.classList.add("hidden"); }
}

function togglePoseCustom() {
    let curve = document.getElementById("curveTypePose").value; let mode = document.getElementById("poseCalcMode").value;
    let secRaw = parseFloat(document.getElementById("poseSeconds").value); let sec = isNaN(secRaw) ? 1 : secRaw;
    let wrap = document.getElementById("customEditorWrap_pose"); let warn = document.getElementById("warnCustomPose");
    if(curve === "custom") {
        wrap.classList.remove("hidden");
        if(mode !== "seconds" || sec < 3 || mode === "ai") {
            wrap.classList.add("disabled"); if(warn) { warn.innerText = i18n[currentLang].warnCustomPose; warn.classList.remove("hidden"); }
        } else {
            wrap.classList.remove("disabled"); if(warn) warn.classList.add("hidden");
            initCustomCanvas('pose'); requestAnimationFrame(() => drawCustomEditor('pose'));
        }
    } else { wrap.classList.add("hidden"); if(warn) warn.classList.add("hidden"); }
}

// ================================================================
// GRAPH RENDERING
// ================================================================
function setupHighResCanvas(canvasId, width, height) {
    let canvas = document.getElementById(canvasId); if(!canvas) return null;
    let ctx = canvas.getContext("2d"); let dpr = window.devicePixelRatio || 1;
    canvas.width = width * dpr; canvas.height = height * dpr; canvas.style.width = width + "px"; canvas.style.height = height + "px";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); return { canvas, ctx, w: width, h: height };
}

function drawPill(ctx, text, x, y, bgColor, color) {
    ctx.font = "600 11px 'Be Vietnam Pro', sans-serif"; let tw = ctx.measureText(text).width;
    ctx.fillStyle = bgColor; ctx.beginPath(); ctx.roundRect(x - tw/2 - 7, y - 10, tw + 14, 20, 10); ctx.fill();
    ctx.fillStyle = color; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(text, x, y + 1);
}

function renderStaticCurve(canvasId, curveType, tab) {
    let res = setupHighResCanvas(canvasId, 530, 110); if(!res) return;
    let { ctx, w, h } = res; let padX = 30, padY = 15; let usableW = w - padX*2; let usableH = h - padY*2; let midY = h/2;
    ctx.clearRect(0, 0, w, h); let dx = 0.001; let rawSpeeds = [];
    for(let i=0; i<=100; i++) {
        let x = i/100; let x0 = Math.max(0,x-dx); let x1 = Math.min(1,x+dx);
        let y0 = getPacingCurve(x0, curveType, tab); let y1 = getPacingCurve(x1, curveType, tab);
        rawSpeeds.push((x1>x0) ? (y1-y0)/(x1-x0) : 1);
    }
    ctx.beginPath(); ctx.moveTo(padX, midY); ctx.lineTo(w-padX, midY);
    ctx.strokeStyle = "rgba(255,204,102,0.4)"; ctx.setLineDash([4,4]); ctx.lineWidth = 1.5; ctx.stroke(); ctx.setLineDash([]);
    ctx.beginPath();
    for(let i=0; i<=100; i++) {
        let x = i/100; let yOffset = (rawSpeeds[i]-1) * (usableH/3); let yPos = Math.max(padY-5, Math.min(h-padY+5, midY - yOffset));
        if(i===0) ctx.moveTo(padX + x*usableW, yPos); else ctx.lineTo(padX + x*usableW, yPos);
    }
    ctx.strokeStyle = "#ffcc66"; ctx.lineWidth = 3; ctx.lineCap = "round"; ctx.lineJoin = "round"; ctx.stroke();
    ctx.beginPath(); ctx.moveTo(padX-10, h-padY); ctx.lineTo(w-padX+10, h-padY);
    ctx.strokeStyle = "#1e3a5f"; ctx.lineWidth = 2.5; ctx.stroke();
}

function renderGraph(canvasId, mainKeys, subKeys, minF, maxF, requiredWidth) {
    let padYBottom = 45; let res = setupHighResCanvas(canvasId, requiredWidth, 90 + padYBottom); if(!res) return;
    let { ctx, w, h } = res; let padX = 30, padY = 25; let usableW = w-padX*2; let usableH = h-padYBottom-padY;
    let range = maxF - minF; if(range <= 0) range = 1;
    ctx.beginPath();
    mainKeys.forEach((key, index) => {
        let x = padX + ((key-minF)/range)*usableW; let y = h - padYBottom - (mainKeys.length>1 ? (index/(mainKeys.length-1))*usableH : usableH/2);
        if(index===0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    });
    ctx.strokeStyle = "#00ccff"; ctx.lineWidth = 3; ctx.lineCap = "round"; ctx.lineJoin = "round"; ctx.stroke();
    ctx.beginPath(); ctx.moveTo(padX-10, h-padYBottom); ctx.lineTo(w-padX+10, h-padYBottom);
    ctx.strokeStyle = "#1e3a5f"; ctx.lineWidth = 2.5; ctx.stroke();
    if(subKeys && subKeys.length > 0) {
        let dedupSubs = [...new Set(subKeys)];
        dedupSubs.forEach(key => {
            let x = padX + ((key-minF)/range)*usableW;
            ctx.beginPath(); ctx.arc(x, h-padYBottom, 4, 0, Math.PI*2); ctx.fillStyle = "#00ccff"; ctx.fill();
            drawPill(ctx, key, x, h-padYBottom-18, "rgba(0,204,255,0.15)", "#00ccff");
        });
    }
    let lastTextX = -999; let staggerLevel = 0;
    mainKeys.forEach((key, index) => {
        let x = padX + ((key-minF)/range)*usableW; let y = h-padYBottom - (mainKeys.length>1 ? (index/(mainKeys.length-1))*usableH : usableH/2);
        ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, h-padYBottom); ctx.strokeStyle = "rgba(0,204,255,0.3)"; ctx.lineWidth = 1.5; ctx.stroke();
        ctx.beginPath(); ctx.arc(x, y, 4, 0, Math.PI*2); ctx.fillStyle = "#fff"; ctx.fill();
        ctx.beginPath(); ctx.arc(x, h-padYBottom, 5, 0, Math.PI*2); ctx.fillStyle = "#ffcc66"; ctx.fill();
        if(x - lastTextX < 32) { staggerLevel = (staggerLevel+1)%3; } else { staggerLevel = 0; }
        lastTextX = x; let textY = h-padYBottom+12+(staggerLevel*14);
        drawPill(ctx, key, x, textY, "rgba(255,204,102,0.15)", "#ffcc66");
    });
}

// ================================================================
// TAB SWITCHING
// ================================================================
function switchTab(tab) {
    ["convertMode","animeMode","poseMode","renderMode"].forEach(id => document.getElementById(id).classList.add("hidden"));
    ["tabConvert","tabAnime","tabPose","tabRender"].forEach(id => document.getElementById(id).classList.remove("active"));
    document.getElementById(tab + "Mode").classList.remove("hidden");
    document.getElementById("tab" + tab.charAt(0).toUpperCase() + tab.slice(1)).classList.add("active");
    if(tab === "convert") updateConvert();
    if(tab === "anime") { toggleAnimePoseInput(); toggleAnimeCustom(); updateAnime(); }
    if(tab === "pose")  { togglePoseSettings(); togglePoseCustom(); updatePoseEst(); }
    if(tab === "render") updateRender();
    updateAllCustomSelects();
}

function setField(id, val) { document.getElementById(id).value = val; }

// ================================================================
// CONVERT
// ================================================================
function updateConvert() {
    let mode = document.getElementById("mode").value; let fps = parseFloat(document.getElementById("fps").value);
    let val = parseFloat(document.getElementById("inputValue").value); let tUnit = document.getElementById("timeUnit");
    let isTime2Frame = (mode === "t2f");
    tUnit.classList.toggle("hidden", !isTime2Frame);
    if(tUnit.parentNode && tUnit.parentNode.classList.contains("custom-select-wrapper")) tUnit.parentNode.classList.toggle("hidden", !isTime2Frame);
    if(isNaN(val)||isNaN(fps)||fps<=0||val<0) { document.getElementById("convertOutput").innerHTML = "‚Äî"; return; }
    if(mode === "f2t") {
        let totalSec = val/fps; let mainStr = totalSec.toFixed(3) + " " + i18n[currentLang].dynSec;
        let h2 = Math.floor(totalSec/3600), m = Math.floor((totalSec%3600)/60), s = parseFloat((totalSec%60).toFixed(3));
        let subStr = (h2>0||m>0) ? `<span class="sub-result">‚âà ${h2>0?h2+"h ":""}${m}m ${s}s</span>` : "";
        document.getElementById("convertOutput").innerHTML = mainStr + subStr;
    } else {
        let frames = Math.round(val * parseFloat(tUnit.value) * fps); document.getElementById("convertOutput").innerHTML = frames + " " + i18n[currentLang].dynFrames;
    }
}

// ================================================================
// ANIME TAB
// ================================================================
function toggleAnimePoseInput() {
    let logic = document.getElementById("calcLogic").value;
    let isAI = logic === "ai";
    injectAiUI('anime', isAI);
    document.getElementById('aiProviderAnime').classList.toggle('hidden', !isAI);

    let hideParams = isAI && !isAiConnected;
    document.getElementById("animeParams").classList.toggle("hidden", hideParams);
    document.getElementById("btnGenerateAiA").classList.toggle("hidden", !isAI);

    let isStatic = document.getElementById("focusState").value === "static";
    let style = document.getElementById("animStyle").value;

    document.getElementById("poseRow").classList.toggle("hidden", isStatic || hideParams);
    document.getElementById("rowCorePacingA").classList.toggle("hidden", isStatic || hideParams);
    document.getElementById("rowCurveTypeA").classList.toggle("hidden", isStatic || hideParams);
    document.getElementById("rowForceA").classList.toggle("hidden", isStatic || style === "1" || hideParams);
}

function updateAnime(aiGeneratedKeys = null) {
    let focusState = document.getElementById("focusState").value; let style = parseInt(document.getElementById("animStyle").value);
    let fps = parseFloat(document.getElementById("fpsAnime").value) || 24; let curve = document.getElementById("curveTypeAnime").value;
    let poses = parseInt(document.getElementById("poseCount").value) || 1; let logic = document.getElementById("calcLogic").value;
    let isForceClamp = document.getElementById("forceClampA").value === "yes";
    
    let sfRaw = parseInt(document.getElementById("startFrame").value); let efRaw = parseInt(document.getElementById("endFrame").value);
    let sfVal = isNaN(sfRaw) ? 1 : sfRaw; let efVal = isNaN(efRaw) ? 100 : efRaw; 
    let sf = Math.min(sfVal, efVal); let ef = Math.max(sfVal, efVal);
    let totalF = ef - sf + 1; let t = i18n[currentLang]; let isTooLong = (totalF/fps) > 25;
    
    let out = `${t.dynTotal} <span style="color:white">${totalF}</span> ${t.dynFrames}<br>`;
    
    if(logic === 'ai') {
        if(!isAiConnected) { document.getElementById("animeOutput").innerHTML = ""; return; }
        if(!aiGeneratedKeys) {
            document.getElementById("animeOutput").innerHTML = out + `<div class="sub-result" style="margin-top:20px;">${t.txtAiReady}</div>`; return;
        }
    }

    if(focusState === "dynamic") {
        let isCustomValid = !(curve==='custom' && (logic!=='strict' || (totalF/fps)<3));
        if(!isCustomValid && logic !== 'ai') {
            out += `<div class="warning" style="text-align:left; margin-top:15px; color:#ffcc66; border-color:#ffcc66;">${t.warnCustomAnime}</div>`;
            document.getElementById("animeOutput").innerHTML = out; return;
        }
        
        let keys = []; let isClamped = false; let clampedTo = 0; let missingPoses = 0;
        if(logic === 'ai') {
            keys = [...new Set(aiGeneratedKeys)].sort((a,b)=>a-b);
        } else {
            if(curve==='custom') updateCustomLUT('anime');
            if(poses === 1) keys.push(sf);
            else {
                for(let i=0; i<poses; i++) {
                    let x = i/(poses-1); let p = sf + getPacingCurve(x, curve, 'anime') * (totalF-1);
                    if(logic==="random" && i>0 && i<poses-1) {
                        let prevX=(i-1)/(poses-1); let nextX=(i+1)/(poses-1);
                        let prevP=sf+getPacingCurve(prevX,curve,'anime')*(totalF-1);
                        let nextP=sf+getPacingCurve(nextX,curve,'anime')*(totalF-1);
                        let maxJitter=Math.max(style * 0.8, Math.min(p-prevP,nextP-p)*0.4);
                        p+=(Math.random()*maxJitter*2)-maxJitter;
                    }
                    let rawSnap = sf + Math.round((p-sf)/style)*style;
                    keys.push(Math.max(sf, Math.min(ef, rawSnap)));
                }
                let uniqueKeys = [...new Set(keys)].sort((a,b)=>a-b);
                missingPoses = poses - uniqueKeys.length; keys = uniqueKeys;
            }
        }
        
        if(keys.length > 0) {
            let lastKey = keys[keys.length-1];
            if(lastKey !== ef) { isClamped = true; clampedTo = lastKey; } 
            else if(keys.length > 1) { let secondLast = keys[keys.length-2]; if((lastKey - secondLast) % style !== 0) { isClamped = true; clampedTo = lastKey; } } 
            else { if((lastKey - sf) % style !== 0) { isClamped = true; clampedTo = lastKey; } }
        }
        
        let isShortage = totalF < style * keys.length;
        let pacingA = document.getElementById("corePacingAnime").value; let focusA = document.getElementById("focusTarget").value; let baseDensityA = 1.0;
        if(pacingA==="superslow") baseDensityA=0.2; else if(pacingA==="slowmo") baseDensityA=0.4; else if(pacingA==="slow") baseDensityA=0.6;
        else if(pacingA==="fast") baseDensityA=1.5; else if(pacingA==="superfast") baseDensityA=2.0; else if(pacingA==="timesplash") baseDensityA=1.2;
        if(focusA==="scene") baseDensityA *= 0.5;

        let idealPoses = Math.max(2, Math.round((totalF / style) * 0.2 * baseDensityA));
        let idealText = currentLang === 'vi' ? 'G·ª£i √Ω s·ªë Pose l√Ω thuy·∫øt' : 'Suggested theoretical Pose count';
        
        out += `<div class="box-result"><b>${t.dynKeysSugg}:</b><br>${keys.join(" ‚ûî ")}<br><span style="color:#9ed8ff; font-size:12px; margin-top:5px; display:block;">* ${idealText}: <b>${idealPoses}</b></span></div>`;
        if(missingPoses>0) out += `<div class="warning" style="text-align:left;margin-top:15px;color:#ffcc66;border-color:#ffcc66;">${t.dynMissingPose} <b>${missingPoses}</b>.</div>`;
        
        if((isClamped||isShortage) && style !== 1) {
            let isSafeToForce = totalF >= fps; 
            if (isForceClamp && isSafeToForce && !isShortage) {
                out += `<div class="box-result box-safe" style="margin-top:15px;">‚ö†Ô∏è ${t.dynForceSafe1} <b>${clampedTo}</b> ${t.dynForceSafe2}</div>`;
            } else {
                let rem = (ef - sf) % style;
                if(rem !== 0) {
                    let idealDown = ef - rem; let idealUp = ef + (style - rem);
                    let suggestion = `${t.dynSuggestFrame1} <b>${idealDown}</b> ${t.dynSuggestFrame2} <b>${idealUp}</b> ${t.dynSuggestFrame3}`;
                    out += `<div class="warning" style="text-align:left;margin-top:15px;">${t.dynClampWarn1}<b>${clampedTo||keys[keys.length-1]}</b>${t.dynClampWarn2}<b>${style}</b>${t.dynClampWarn3}<br>‚ûî ${suggestion}</div>`;
                } else {
                    out += `<div class="warning" style="text-align:left;margin-top:15px;">${t.dynClampWarn1}<b>${clampedTo||keys[keys.length-1]}</b>${t.dynClampWarn2}<b>${style}</b>${t.dynClampWarn3}</div>`;
                }
            }
        }
        
        if(isTooLong) {
            out += `<div class="warning" style="text-align:left;margin-top:15px;color:#ff6b6b;border-color:#ff6b6b;">${t.dynGraphLimitWarn}</div>`;
        } else {
            out += `<div class="graph-title" style="margin-top:25px;margin-bottom:8px;"><span>${t.lblVisualGraph}</span><span class="tooltip" data-tip="${t.tipVisualGraph}">?</span></div>
            <div class="static-graph-wrapper"><canvas id="animeStaticGraph" class="graph-canvas"></canvas></div>
            <div class="graph-title" style="margin-top:25px;margin-bottom:8px;"><span>${t.lblDataGraph}</span><span class="tooltip" data-tip="${t.tipDataGraph}">?</span></div>
            <div class="graph-wrapper"><canvas id="animeGraph" class="graph-canvas"></canvas></div>
            <div class="graph-legend-box"><span style="color:#ffcc66">‚óè</span><span data-i18n="legendMainKey">${t.legendMainKey}</span></div>`;
        }
        document.getElementById("animeOutput").innerHTML = out;
        if(!isTooLong) {
            let requiredWidth = Math.max(530, keys.length*40);
            renderStaticCurve("animeStaticGraph", curve, 'anime');
            renderGraph("animeGraph", keys, [], sf, ef, requiredWidth);
        }
    } else {
        out += `<div class="box-result"><b style="color:#ffcc66;">${t.dynStaticTitle}</b><br>${t.dynStaticDesc} (${currentLang==='vi'?'ƒë·∫∑t t·∫°i':'placed at'} frame ${sf}) ${t.dynStaticHold} ${totalF} ${t.dynFrames}.</div>`;
        document.getElementById("animeOutput").innerHTML = out;
    }
}

// ================================================================
// POSE TAB
// ================================================================
function updateJerkHint() {
    let jerkType = document.getElementById("jerkToggle").value; let hintEl = document.getElementById("jerkHint");
    if(jerkType==="frame") {
        let style = parseInt(document.getElementById("animStylePose").value)||2; let fps = parseFloat(document.getElementById("fpsPose").value)||24;
        let min = style*2; let max = Math.round((fps/24)*6)*style; if(max<min) max=min+style;
        hintEl.innerText = `${i18n[currentLang].dynHintFrames}${min} - ${max} frames`; hintEl.classList.remove("hidden");
    } else { hintEl.classList.add("hidden"); }
}

function togglePoseSettings() {
    let logic = document.getElementById("poseCalcMode").value;
    let isAI = logic === "ai";
    injectAiUI('pose', isAI);
    document.getElementById('aiProviderPose').classList.toggle('hidden', !isAI);

    let hideParams = isAI && !isAiConnected;
    document.getElementById("poseParams").classList.toggle("hidden", hideParams);
    document.getElementById("btnGenerateAiP").classList.toggle("hidden", !isAI);

    let style = document.getElementById("animStylePose").value;
    let sub = document.getElementById("subPoseToggle").value;
    document.getElementById("rowPoseSeconds").classList.toggle("hidden", logic!=="seconds" && logic!=="ai");
    document.getElementById("rowSubPoseLogic").classList.toggle("hidden", sub!=="yes" || hideParams);
    document.getElementById("rowForceP").classList.toggle("hidden", style === "1" || hideParams);
    
    if(sub==="yes") {
        document.getElementById("rowJerkiness").classList.add("hidden"); document.getElementById("jerkToggle").value = "no";
        if(document.getElementById("jerkToggle").updateCustomUI) document.getElementById("jerkToggle").updateCustomUI();
    } else {
        document.getElementById("rowJerkiness").classList.toggle("hidden", hideParams);
    }
    let jerkType = document.getElementById("jerkToggle").value; let inputBlock = document.getElementById("jerkInputBlock");
    if(jerkType==="no") { inputBlock.classList.add("hidden"); } 
    else { inputBlock.classList.remove("hidden"); let jInput = document.getElementById("jerkValue"); jInput.step = jerkType==="sec" ? "0.1" : "1"; updateJerkHint(); }
}

function togglePoseActions() {
    let type = document.getElementById("focusTypePose").value; let charSel = document.getElementById("focusActionChar"); let objSel = document.getElementById("focusActionObj");
    let charWrap = charSel.previousElementSibling; let objWrap = objSel.previousElementSibling;
    if(type==="char") {
        objSel.classList.add("hidden"); if(objWrap && objWrap.classList.contains("custom-select-wrapper")) objWrap.style.display="none";
        charSel.classList.remove("hidden"); if(charWrap && charWrap.classList.contains("custom-select-wrapper")) charWrap.style.display="";
    } else {
        charSel.classList.add("hidden"); if(charWrap && charWrap.classList.contains("custom-select-wrapper")) charWrap.style.display="none";
        objSel.classList.remove("hidden"); if(objWrap && objWrap.classList.contains("custom-select-wrapper")) objWrap.style.display="";
    }
}

let currentRandomSec = null;

function updatePoseEst(aiGeneratedKeys = null) {
    let mode = document.getElementById("poseCalcMode").value;
    let secRaw = parseFloat(document.getElementById("poseSeconds").value);
    let sec = isNaN(secRaw) ? 1 : secRaw; if (sec <= 0) sec = 0.042; 
    let totalSec;
    if(mode === "seconds" || mode === "ai") { totalSec = sec; currentRandomSec = null; } 
    else { if(currentRandomSec === null) currentRandomSec = (Math.random() * 3.5 + 1.0); totalSec = currentRandomSec; }
    
    let fps = parseFloat(document.getElementById("fpsPose").value) || 24; let style = parseInt(document.getElementById("animStylePose").value) || 2;
    let pacing = document.getElementById("corePacingPose").value; let curve = document.getElementById("curveTypePose").value;
    let action = document.getElementById("focusTypePose").value==="char" ? document.getElementById("focusActionChar").value : document.getElementById("focusActionObj").value;
    let useSub = document.getElementById("subPoseToggle").value==="yes"; let subRule = document.getElementById("subPoseLogic").value;
    let jerkType = document.getElementById("jerkToggle").value; let jerkRaw = parseFloat(document.getElementById("jerkValue").value);
    let jerkVal = isNaN(jerkRaw) ? (jerkType==="sec"?0.2:4) : jerkRaw; let isForceClamp = document.getElementById("forceClampP").value === "yes";
    let t = i18n[currentLang];
    
    let totalFrames = Math.max(1, Math.round(totalSec * fps)); let isTooLong = totalSec > 25;
    let out = `‚âà ${totalSec.toFixed(2)} ${t.dynSec} | ${totalFrames} ${t.dynFrames}<br>`;

    if(mode === 'ai') {
        if(!isAiConnected) { document.getElementById("poseOutput").innerHTML = ""; return; }
        if(!aiGeneratedKeys) {
            document.getElementById("poseOutput").innerHTML = out + `<div class="sub-result" style="margin-top:20px;">${t.txtAiReady}</div>`; return;
        }
    }

    let isCustomValid = !(curve==='custom' && (mode!=='seconds' || sec < 3));
    if(!isCustomValid && mode !== 'ai') { document.getElementById("poseOutput").innerHTML = `<div class="warning" style="text-align:left;">${t.warnCustomPose}</div>`; return; }

    let baseDensity = 1.0;
    if(pacing==="superslow") baseDensity=0.2; else if(pacing==="slowmo") baseDensity=0.4; else if(pacing==="slow") baseDensity=0.6;
    else if(pacing==="fast") baseDensity=1.5; else if(pacing==="superfast") baseDensity=2.0; else if(pacing==="timesplash") baseDensity=1.2;
    if(["fight","fly","break","run"].includes(action)) baseDensity*=1.4; if(["talk","scale"].includes(action)) baseDensity*=0.6;

    let totalDrawings = Math.floor(totalFrames / style); 
    let mainPoseCount = Math.max(2, Math.round((totalDrawings * 0.2) * baseDensity));
    let maxReasonablePoses = Math.min(24, Math.max(2, Math.floor(totalDrawings / 2)));
    mainPoseCount = Math.min(mainPoseCount, maxReasonablePoses);

    let keys = []; let isClamped = false; let clampedTo = 0; let rawKeyCount = 0;

    if(mode === 'ai') {
        keys = [...new Set(aiGeneratedKeys)].sort((a,b)=>a-b);
        rawKeyCount = keys.length;
    } else {
        if(curve==='custom') updateCustomLUT('pose');
        for(let i=0; i<mainPoseCount; i++) {
            let x = i/(mainPoseCount-1 || 1); let p = 1 + getPacingCurve(x, curve, 'pose') * (totalFrames-1);
            let rawSnap = 1 + Math.round((p-1)/style)*style; keys.push(Math.max(1, Math.min(totalFrames, rawSnap)));
        }
        rawKeyCount = keys.length; keys = [...new Set(keys)].sort((a,b)=>a-b);
    }
    
    let missingPoses = rawKeyCount - keys.length; let isShortage = totalFrames < style * keys.length;

    if(keys.length > 0) {
        let lastKey = keys[keys.length-1];
        if(lastKey !== totalFrames) { isClamped = true; clampedTo = lastKey; } 
        else if(keys.length > 1) { let secondLast = keys[keys.length-2]; if((lastKey - secondLast) % style !== 0) { isClamped = true; clampedTo = lastKey; } } 
        else { if((lastKey - 1) % style !== 0) { isClamped = true; clampedTo = lastKey; } }
    }

    out += `<div class="sub-result">${t.dynEstPoses}: ${keys.length} (KFs: ${keys.join(", ")})</div>`;
    if(missingPoses>0) out += `<div class="warning" style="text-align:left;margin-top:15px;color:#ffcc66;border-color:#ffcc66;">${t.dynMissingPose} <b>${missingPoses}</b>.</div>`;

    let boxHtml = ""; let subKeysList = []; let subWarnings = [];
    if(useSub) {
        boxHtml += `<b>${t.dynSubPose}:</b><br>`;
        for(let i=0; i<keys.length-1; i++) {
            let k1=keys[i], k2=keys[i+1]; let subCount = subRule==="random" ? Math.floor(Math.random()*3)+1 : parseInt(subRule);
            let validSlots = []; for(let s=k1+style; s<k2; s+=style) validSlots.push(s);
            if(validSlots.length === 0) { subWarnings.push(`[${k1}‚Üî${k2}]`); } 
            else {
                let subs = []; let stepRatio = validSlots.length / subCount;
                for(let j=0; j<subCount; j++) { let idx = Math.floor((j+0.5)*stepRatio); if(idx<validSlots.length && !subs.includes(validSlots[idx])) { subs.push(validSlots[idx]); subKeysList.push(validSlots[idx]); } }
                if(subs.length < subCount && subs.length > 0) { boxHtml += `‚Ä¢ ${t.dynSubBetween} [${k1}] ‚Üí [${k2}]: ${subs.join(", ")} <span style="color:#ffcc66;font-size:11px;">(${subs.length}/${subCount})</span><br>`; } 
                else if(subs.length > 0) { boxHtml += `‚Ä¢ ${t.dynSubBetween} [${k1}] ‚Üí [${k2}]: ${subs.join(", ")}<br>`; }
            }
        }
        if(subWarnings.length > 0) { boxHtml += `<span style="color:#ffcc66;font-size:12px;">${t.dynSubNoSlot} ${subWarnings.join(", ")}</span><br>`; }
    }
    
    if(jerkType!=="no" && !useSub && jerkVal>0) {
        boxHtml += `<hr style="border-color:#1e3a5f;margin:10px 0;"><b>${t.dynHold}:</b><br>`;
        let actualJerkVal = jerkVal; let isCappedHold = false;
        if(jerkType==="sec") { let maxSec = totalSec*0.4; if(actualJerkVal>maxSec) { actualJerkVal=maxSec; isCappedHold=true; } } 
        else { let maxFrames = Math.max(1, Math.floor(totalFrames*0.4)); if(actualJerkVal>maxFrames) { actualJerkVal=maxFrames; isCappedHold=true; } }
        let unitText = jerkType==="sec" ? t.dynSec : t.dynFrames; actualJerkVal = jerkType==="sec" ? actualJerkVal.toFixed(2) : Math.round(actualJerkVal);
        boxHtml += `${t.dynHoldMsg1} <b>${actualJerkVal}</b> ${unitText} ${t.dynHoldMsg2}`;
        if(isCappedHold) boxHtml += `<br><span style="color:#ffcc66;font-size:12px;">${t.dynHoldCapNote}</span>`;
    }

    if(boxHtml!=="") out += `<div class="box-result">${boxHtml}</div>`;
    
    if((isClamped||isShortage) && style !== 1) {
        let isSafeToForce = totalFrames >= fps;
        if(isForceClamp && isSafeToForce && !isShortage) {
            out += `<div class="box-result box-safe" style="margin-top:15px;">‚ö†Ô∏è ${t.dynForceSafe1} <b>${clampedTo}</b> ${t.dynForceSafe2}</div>`;
        } else {
            let rem = (totalFrames - 1) % style;
            if(rem !== 0) {
                let idealDownF = totalFrames - rem; let idealUpF = totalFrames + (style - rem);
                let idealDownS = (idealDownF / fps).toFixed(2); let idealUpS = (idealUpF / fps).toFixed(2);
                let suggestion = mode === "seconds" || mode === "ai"
                    ? `${t.dynSuggestSec1} <b>${idealDownS}s</b> (${idealDownF}f) ${t.dynSuggestSec2} <b>${idealUpS}s</b> (${idealUpF}f) ${t.dynSuggestFrame3}`
                    : `${t.dynSuggestFrame1} <b>${idealDownF}</b> ${t.dynSuggestFrame2} <b>${idealUpF}</b> ${t.dynSuggestFrame3}`;
                out += `<div class="warning" style="text-align:left;margin-top:15px;">${t.dynClampWarn1}<b>${clampedTo||keys[keys.length-1]}</b>${t.dynClampWarn2}<b>${style}</b>${t.dynClampWarn3}<br>‚ûî ${suggestion}</div>`;
            } else { out += `<div class="warning" style="text-align:left;margin-top:15px;">${t.dynClampWarn1}<b>${clampedTo||keys[keys.length-1]}</b>${t.dynClampWarn2}<b>${style}</b>${t.dynClampWarn3}</div>`; }
        }
    }

    if(isTooLong) { out += `<div class="warning" style="text-align:left;margin-top:15px;color:#ff6b6b;border-color:#ff6b6b;">${t.dynGraphLimitWarn}</div>`; } 
    else {
        out += `<div class="graph-title" style="margin-top:25px;margin-bottom:8px;"><span>${t.lblVisualGraph}</span><span class="tooltip" data-tip="${t.tipVisualGraph}">?</span></div>
        <div class="static-graph-wrapper"><canvas id="poseStaticGraph" class="graph-canvas"></canvas></div>
        <div class="graph-title" style="margin-top:25px;margin-bottom:8px;"><span>${t.lblDataGraph}</span><span class="tooltip" data-tip="${t.tipDataGraph}">?</span></div>
        <div class="graph-wrapper"><canvas id="poseGraph" class="graph-canvas"></canvas></div>
        <div class="graph-legend-box"><span style="color:#ffcc66">‚óè</span><span>${t.legendMainKey}</span><span style="color:#00ccff;margin-left:15px;">‚óè</span><span>${t.legendSubKey}</span></div>`;
    }
    document.getElementById("poseOutput").innerHTML = out;
    if(!isTooLong) {
        let allKeys = keys.concat([...new Set(subKeysList)]); let requiredWidth = Math.max(530, allKeys.length*40);
        renderStaticCurve("poseStaticGraph", curve, 'pose'); renderGraph("poseGraph", keys, subKeysList, 1, totalFrames, requiredWidth);
    }
}

// ================================================================
// RENDER TAB
// ================================================================
function updateRender() {
    let frames = parseFloat(document.getElementById("totalFrames").value); let pFrame = parseFloat(document.getElementById("renderPerFrame").value);
    if(isNaN(frames)||isNaN(pFrame)||frames<0||pFrame<0) { document.getElementById("renderOutput").innerText = "‚Äî"; return; }
    let tot = frames*pFrame; let d = Math.floor(tot/86400), h = Math.floor((tot%86400)/3600), m = Math.floor((tot%3600)/60), s = Math.floor(tot%60);
    document.getElementById("renderOutput").innerText = (d>0?d+(currentLang==="vi"?" ng√†y ":"d "):"") + `${h}h ${m}m ${s}s`;
}

// ================================================================
// LANGUAGE + I18N
// ================================================================
function changeLang(lang) {
    currentLang = lang; let t = i18n[lang];
    document.querySelectorAll('[data-i18n]').forEach(el => { el.innerText = t[el.getAttribute('data-i18n')]; });
    for(let id in t) {
        let el = document.getElementById(id);
        if(el) {
            if(el.classList.contains("tooltip")) { el.dataset.tip = t[id]; }
            else if(el.tagName==="INPUT" && el.hasAttribute("data-i18n-ph")) { let pKey = el.getAttribute("data-i18n-ph"); if(t[pKey]) el.placeholder = t[pKey]; }
            else { el.innerText = t[id]; }
        }
    }
    let sF = document.getElementById("startFrame"); if(sF) sF.placeholder = t.phStartFrame;
    let eF = document.getElementById("endFrame"); if(eF) eF.placeholder = t.phEndFrame;
    togglePoseSettings(); toggleAnimePoseInput(); updateConvert(); updateAnime(); updatePoseEst(); updateRender(); updateAllCustomSelects(); updateJerkHint();
}

// ================================================================
// CUSTOM DROPDOWNS
// ================================================================
function initCustomSelects() {
    document.querySelectorAll("select").forEach(sel => {
        if(sel.nextElementSibling && sel.nextElementSibling.classList.contains("custom-select-options")) return;
        const wrap = document.createElement("div"); wrap.className = "custom-select-wrapper";
        sel.parentNode.insertBefore(wrap, sel); wrap.appendChild(sel);
        const trig = document.createElement("div"); trig.className = "custom-select-trigger";
        const opts = document.createElement("div"); opts.className = "custom-select-options";
        wrap.appendChild(trig); wrap.appendChild(opts);
        function updateUI() { if(sel.selectedIndex>=0) trig.innerHTML = `<span>${sel.options[sel.selectedIndex].text}</span><div class="arrow"></div>`; }
        function buildOpts() {
            opts.innerHTML = "";
            Array.from(sel.options).forEach((o,i) => {
                const od = document.createElement("div"); od.className = "custom-select-option";
                if(i===sel.selectedIndex) od.classList.add("selected"); od.innerText = o.text;
                od.addEventListener("click", e => { e.stopPropagation(); sel.selectedIndex=i; sel.dispatchEvent(new Event("change")); updateUI(); opts.classList.remove("show"); trig.classList.remove("active"); });
                opts.appendChild(od);
            });
        }
        trig.addEventListener("click", e => {
            e.stopPropagation(); const isS = opts.classList.contains("show");
            document.querySelectorAll(".custom-select-options").forEach(el=>el.classList.remove("show"));
            document.querySelectorAll(".custom-select-trigger").forEach(el=>el.classList.remove("active"));
            if(!isS) { buildOpts(); opts.classList.add("show"); trig.classList.add("active"); }
        });
        updateUI(); sel.style.display="none"; sel.updateCustomUI=updateUI;
    });
    document.addEventListener("click", ()=>{
        document.querySelectorAll(".custom-select-options").forEach(el=>el.classList.remove("show"));
        document.querySelectorAll(".custom-select-trigger").forEach(el=>el.classList.remove("active"));
    });
}
function updateAllCustomSelects() { document.querySelectorAll("select").forEach(s=>{ if(s.updateCustomUI) s.updateCustomUI(); }); }

// ================================================================
// INIT
// ================================================================
window.addEventListener("DOMContentLoaded", ()=>{
    updateCustomLUT('anime'); updateCustomLUT('pose'); initCustomSelects(); changeLang('vi');
    togglePoseActions(); togglePoseSettings(); toggleAnimePoseInput(); initAI();
    document.getElementById("poseCalcMode").addEventListener('change', function() { if (this.value === "random") { currentRandomSec = null; updatePoseEst(); } });
});
</script>
</body>
</html>
